@name RLC Titanium
@inputs Start Pod:entity EmBrake UsingRearSeat HEP_Up HEP_Down [Trucks FrontPlugIn RearPlugIn]:array Sand BatteryKnifeSwitch ReFuel Primer Stop 
@outputs On Reverser Notch RealNotch Brake Dynamics DynaNotch MPH KPH V Clag ConstantClag LocoBrakePressure Emergency AB16M_Notch LB16M_Notch AB26L LB26L [FrontPlugOut RearPlugOut]:array CarCount WheelSlip Sanding RLCPT:entity Unlocked HEP_Mode Load BrakeInfo:array CurrentFuel TankFull TankLow
@persist [Idles Behavior]:array [Transition Startup Shutdown]:string Notch TargetNotch SQ On NQ TQ [UpDelays DownDelays]:array StartupClagStart StartupClagDuration
@persist [DynoOn DynoOff Lever_ReverserF Lever_ReverserN Lever_ReverserB Lever_Throttle Lever_16M Lever_26L]:string
@persist RevQ DynaQ E:entity Starting Dynamics DynamicsEnable DNQ
@persist [Controls Routing]:table Alternate:string Alternate2:string
@persist Horsepower TE_Starting TECON W:entity
@persist AirBrakeType LocoBrakePressure AB16M_Notch LB16M_Notch ABQ [WheelSound BrakeScreech]:string WQ BQ EMQ BPQ CarCount Threshold_Hard Locked LBQ
@persist [AirBrakeApply AirBrakeRelease Lever_LocoBrake LocoBrakeRelease EmergencyBrakeSound]:string THQ IHQ 
@persist MaxLocoBrakeForce MaxTrainBrakeForce BrakeMul HBQ Lever_HandBrake:string MU_OffsetPitch CarCount_Init O:entity ControlPrintOrder:array
@persist WheelSlipProb ETC [SanderOn SanderOff WheelSlipSound1 WheelSlipSound2]:string SandQ Sanding WSQ WSC
@persist Trig2 OldNotch DPM DPM_Delay DPM_Pitch DPMH:entity DPMS:string HEP HEP_Lock HEPQ
@persist [CompressorOn CompressorOff]:string ER Compressing MaxER AB26L LB26L LB26L_ClickQ BlendedBraking BlendQ InfiniteAir
@persist MainRes EqualRes BrakeLine BrakeCyl Switching
@persist FuelSaver LowIdle:string LowIdling Mode3Q SaverQ 
@persist CurrentFuel UseMul UseRate TankMax ReFRate A1 Primed
@trigger Start ReFuel BatteryKnifeSwitch Primer
@model models/cheeze/beta/white_button.mdl
if(first()|dupefinished()){
    #[
    Beta v1.16 
    
        Welcome to Magnum's RLC Platinum (RLC Pt for short) propulsion system modified by Shomi and Dev, renamed RLC Titanium!
        Added a fuel system, fuel priming, battery switch function, a constant clag function and a sander which is controlled via button.
        Installation is almost the same as RLC AB, except:
            *You need to wire Trucks[ARRAY] to an Adv. Ent marker that is linked to the trucks of the locomotive.
            *Pod[ENTITY] goes to the Pod Controller's "Entity" output (NOT to "Create Entity"!!!)
            *The Primer and Stop switch is Non-Toggled
        
    Full Setup Instructions:
        
        1- Configure Locomotive Config and Control Config for your Locomotive
        2- Place chip onto Locomotive body like you would attach a thruster. The Shiny bit needs to face backwards, towards the REAR of the locomotive. DO NOT PARENT IT!
        3a- Wire "Prime" to a NON-TOGGLED button.
        3b- Wire "BatteryKnifeSwitch" to a TOGGLED button.
        3c- Wire "Start"* to a TOGGLED button.
        3d- Wire "Stop" to a NON-TOGGLED button.
        5a- If you plan on using multiple units: Spawn a wire plug (with the ARRAY tickbox checked) on each end of the locomotive. DO NOT PARENT THEM!
        5b- Wire the Plugs to FrontPlugOut[ARRAY] and RearPlugOut[ARRAY], respectively, and wire FrontPlugIn[ARRAY] and RearPlugIn[ARRAY] to the chip.
        6- Make a bunch of indicators or screens or whatever in the cab so you can see what's going on.
        7- Weight the Locomotive: 40,000 for the Body/Baseplate, 20,000 for each truck. Also, you may want to disable collisions on the Body/Baseplate.
        
    *Start is actually the isolation.
    
    Chat Commands:
    
        .engine - Toggles the Engine.
        .reverser <N> - Changes the Reverser.
        .notch <N> - Changes the engine Notch.
        .brake <N> - Changes the Trainline Brake Pressure. If no argument, applies the Emergency Brake.
        .dynamics <N> - Engages/Disengages the Dynamic Brakes.
        .handbrake - Applies the Handbrake, which gives a rubber physprop to all cars in the consist.
        .controls - Prints the controls to your chat.
        .superice - "super ices" the entire train (Note: actually uses "friction_00").
        .count - Prints the total number of connected cars, assuming 3-prop cars.
        
    Miscellaneous Notes:
    
        The MU System is backwards compatible with RLC and RLC AB, but the RLC Platinum unit /MUST/ be the master unit!
        
    ]#
    #-----------------
    #Locomotive Config
    #-----------------
    
    #\\\\\\\\\\\\\\\\\\\\\\\\\
    
    local LocomotiveType = "EMD E9" #The Locomotive model designation, for naming purposes.
    local EngineType = "EMD 567c" #The Engine model, for naming purposes.
    
    Horsepower = 2400 #Horsepower, Duh
    TE_Starting = 80000 #Starting Tractive effort, in lbf.
    
    #/////////////////////////
    
    
    
    
    DynamicsEnable = 1 #0 for No Dynamic Braking
                       #1 for Normal Dynamic Braking
                       #2 for "Notch 4" Dynamic Braking (ALCO style)
                       #3 for Blended Dynamic Braking (Modern Passenger Locomotives)
    
    ETC = 0 #Electronic Traction Control setting. 0 for no ETC (Hard), 1 for ETC (Easy), 2 to Disable Wheelslip entirely (Lazy).
    
    AirBrakeType = 0 #0 for 16M Airbrakes (Harder), 1 for 26L Airbrakes (Easier).
    
    #26L Airbrakes are more modern, and can provide up to 90psi of pressure. The Increase and Decrease keys will add/subtract pressure for as long as you hold them.
    #16M Airbrakes are older. There are three Notches: "Release," "Lap," and "Apply." While in "Release" or "Apply," the
    #brake pressure will continually increase or decrease until it hits the upper or lower limit. In "Lap," the pressure will be held constant.
    
    
    HEP = 1 #Set this to 1 if the locomotive is equipped for passenger service and uses the Prime Mover as HEP generators.
    DPM = 1 #if 1, will play an additional prime mover sound in addition to the main one
    BrakeMul = 775 #Don't Touch This
    
    #--------------
    #Control Config
    #--------------
    
    #You can actually change this, but be careful.
    #Wiremod key names do not always coincide with source key names!
    
    Alternate = "lshift" #When pressing this key, all controls with "!ALT" next to them will be triggered, and all the other will be ignored.
    Alternate2 = "lalt" #When pressing this key, all controls with "!ALT" next to them will be triggered, and all the other will be ignored.
    
    
    Controls["ReverserF",string]        = "W"
    Controls["ReverserB",string]        = "S"
    
    Controls["IncreaseThrottle",string] = "D"
    Controls["DecreaseThrottle",string] = "A"
    
    Controls["IncreaseDynamics",string] = "W !ALT"
    Controls["DecreaseDynamics",string] = "S !ALT"
    
    Controls["IncreaseTrainBrake",string]    = "enter"
    Controls["DecreaseTrainBrake",string]    = "rcontrol"
    
    Controls["IncreaseLocoBrake",string] = "shift"
    Controls["DecreaseLocoBrake",string] = "control"
    
    
    Controls["EmergencyBrake",string] = "ralt"
    
    Controls["HandBrake",string] = "H"
    Controls["Sander",string] = "X"
    
    
    
    #Ignore this
    ControlPrintOrder = array("ReverserF","ReverserB","IncreaseThrottle","DecreaseThrottle","IncreaseDynamics","DecreaseDynamics","IncreaseTrainBrake","DecreaseTrainBrake","IncreaseLocoBrake","DecreaseLocoBrake","EmergencyBrake","HandBrake","Sander")
    
    
    
    #-----------------
    #Sound/Clag Config
    #-----------------
    
    #You probably shouldn't touch anything below here unless you REALLY know what you're doing.
    
    #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    
    Startup = "gsgtrainsounds/emd567/startup.wav"   #Startup and Shutdown
    Shutdown = "gsgtrainsounds/emd567/shutdown.wav"
    
    StartupClagStart = 2.5      #Clag Config
    StartupClagDuration = 3.5
    
    Idles = array(                                  #Sounds used for each Notch
    "gsgtrainsounds/emd567/idle.wav",
    "gsgtrainsounds/emd567/notch1.wav",
    "gsgtrainsounds/emd567/notch2.wav",
    "gsgtrainsounds/emd567/notch3.wav",
    "gsgtrainsounds/emd567/notch4.wav",
    "gsgtrainsounds/emd567/notch5.wav",
    "gsgtrainsounds/emd567/notch6.wav",
    "gsgtrainsounds/emd567/notch7.wav",
    "gsgtrainsounds/emd567/notch8.wav"
    )
    Transition = "gsgtrainsounds/emd567/transitions/" #The folder path for the transition sounds.
    
                    #1-2 2-3 3-4 4-5 5-6 6-7 7-8 
    UpDelays = array(950,400,400,500,550,600,500)
                      #8-7 7-6 6-5 5-4 4-3 3-2 2-1
    DownDelays = array(650,800,750,850,600,800,750)
                    #0-1 1-2 2-3 3-4 4-5 5-6 6-7 7-8
    Behavior = array(3,  0,  0,  0,  0,  0,  0,  0)
    #0: Normal A/B Notching
    #1: Full Sweep
    #2: Instant Transition
    #3: No Change
    
    #///////////////////////////////////
    
    LowIdle = "gsgtrainsounds/emd645t/idle_low.wav" #Don't touch these unless you know what you are doing!
    FuelSaver = 0, LowIdling = 0
    
    DynoOn = "gsgtrainsounds/misc/emd_dynb_loop.wav"    #Dynamic Brake Sounds
    DynoOff = "gsgtrainsounds/misc/emd_dynb_stop.wav"
    
    Lever_ReverserF = "gsgtrainsounds/misc/reverser_f.wav"      #Cab Lever Sounds
    Lever_ReverserN = "gsgtrainsounds/misc/reverser_neutral.wav"
    Lever_ReverserB = "gsgtrainsounds/misc/reverser_r.wav"
    
    Lever_Throttle = "buttons/lightswitch2.wav" 
    
    Lever_16M = "gsgtrainsounds/misc/airbrakes/air_16m_move.wav"
    Lever_26L = "gsgtrainsounds/misc/airbrakes/air_26l_move.wav"
    
    Lever_LocoBrake = "gsgtrainsounds/misc/airbrakes/air_ind_full.wav"
    Lever_HandBrake = "buttons/lever4.wav"
    
    WheelSound = "gsgtrainsounds/misc/train_wheels_welded_loop.wav"     #Wheel Noises
    BrakeScreech = "gsgtrainsounds/wheels/brake_3_loud.wav"             #Brake Screech
    
    AirBrakeApply = "gsgtrainsounds/misc/airbrakes/air_train_apply.wav"     #Sounds for Trainline Airbrakes
    AirBrakeRelease = "gsgtrainsounds/misc/airbrakes/air_train_release.wav"   
    
    LocoBrakeRelease = "gsgtrainsounds/misc/airbrakes/air_ind_release2.wav" #Locomotive brakes' apply sounds are very quiet so we just included a release.
    
    EmergencyBrakeSound = "gsgtrainsounds/misc/airbrakes/air_dump.wav"  #The sound of the engineer shitting his pants
    
    CompressorOn = "_jazzlok/brakes/compressor_start_loop.wav"
    CompressorOff = "_jazzlok/brakes/compressor_stop.wav"
    
    SanderOn = "gsgtrainsounds/misc/airbrakes/air_sander_loop.wav"    #Not to be confused with Bernie Sanders
    SanderOff = "gsgtrainsounds/misc/airbrakes/air_sander_end.wav"
    
    WheelSlipSound1 = "gsgtrainsounds/wheels/wheelslip1.wav"  #Sounds for Wheelslip
    WheelSlipSound2 = "gsgtrainsounds/wheels/wheelslip2.wav"
    
    Threshold_Hard = 0.25 #Speed, in mph, below which the train brakes will hold the train.
    
    
    DPM_Delay = 200 #Delay in ms for the 2nd prime mover to get the message
    DPM_Pitch = 2 #Extra Pitch to give the 2nd Prime Mover
    
    #Fuel stuff
    UseMul = 100
    UseRate = 0.05
    TankMax = 2600
    ReFRate = 5
    CurrentFuel = 0
    
    
    #Sound Index Register (You don't need to know this)
    
    #0 - Engine Sounds
    #1 - Cab Levers
    #2 - Dynamic Brake Fans
    #3 - Wheel Sound
    #4 - Brake Screech
    #5 - Train Brake Hiss
    #6 - Sander
    #7 - Dual Prime Mover
    #8 - Air Compressor
    
    
    #----
    #Init
    #----
    
    if(BatteryKnifeSwitch < 1){
        Start = 0
        }
    #Controls Init
    
    foreach(K,V:string = Controls){
        if(V:find(" !ALT")){
            Routing[K,number] = 1
            local EXP = V:explode(" ")
            Controls[K,string] = EXP[1,string]
        }else{
            Routing[K,number] = 0
        }
    }
    
    #Sounds Init
    
    #DPM
    if(DPM){
        DPMH = holoCreate(0,entity():isWeldedTo():pos(),vec(1),ang(),vec(255),"cube")
        holoParent(0,entity())
        DPMH:propDraw(0)
        
    }
    
    function void lowidlestop(){
        stoptimer("lowidlestart")
        #print("                Stopping Timer")
        SaverQ = 0
    }
    
    #Tickrate-Adjusted Sound Duration
    function number sdr(Soundpath:string){
        local Tick = round(1/tickInterval())
        
        return floor(soundDuration(Soundpath)*100)*10/((Tick==33) ? 2 : 1)
    }
    
    function number startTransition(From,To){
        lowidlestop()
        
        if(To > From){
            Clag = 1
            
            local BType = Behavior[From+1,number]
            if(LowIdling){
                #LowIdling = 0
                LowIdling = 0
                local Snd = Transition + "up/0-1.wav"
                W:soundPlay(0,0,Snd)
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
                timer("level",sdr(Snd))
                
                
                return From+1
            }elseif(BType==1){
                #Full Sweep
                #local Snd = Transition + "up/0-1.wav"
                local Nc = From:toString()
                local Nn = (From+1):toString()
                local Snd = Transition + "up/" + Nc + "-" + Nn + ".wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                local SDR = sdr(Snd)
                timer("level",SDR)
                timer("manclag",floor(SDR/20)*10)
                Mode3Q = 0
                #print("============Full")
                return From 
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType==0){
                #Normal AB
                local Nc = From:toString()
                local Nn = (From+1):toString()
                local Snd = Transition + "up/" + Nc + "-" + Nn + "a.wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("abu",sdr(Snd)-50)
                return From
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType>=2){
                timer("level",500)
                if(BType==3){
                    Mode3Q = 1
                }
                return From+1
                
            
                
            }
        }elseif(To < From){
            Clag = 0
            local BType = Behavior[From,number]
            #print("                                " + BType)
            #Pod:printDriver(BType:toString())
            if(BType==1){
                #Full Sweep
                local Nc = From:toString()
                local Nn = (From-1):toString()
                local Snd = Transition + "down/" + Nc + "-" + Nn + ".wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("level",sdr(Snd))
                Mode3Q = 0
                #print("============Full")
                return From-1
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType==0){
                #Normal AB
                local Nc = From:toString()
                local Nn = (From-1):toString()
                local Snd = Transition + "down/" + Nc + "-" + Nn + "a.wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("abd",sdr(Snd)-50)
                return From
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                } 
            }elseif(BType>=2){
                timer("level",500)
                
                if(BType==3){
                    Mode3Q = 1
                }
                return From-1
                
            }
        }else{
            return From
        }
        
    }
    function number tq_evaluate(From,To){
        return    (From!=To)
    }
    function void entity:printProper(Message:string){
        if(This==O){
            print(Message)
        }else{
            Pod:printDriver(Message)
        }
    }
    
    #Locomotive Init
    Notch = 0
    RealNotch = 0
    Reverser = 0
    AB16M_Notch = AirBrakeType ? 0 : 1
    LB16M_Notch = -1
    
    function number entity:extraProps(Init){
        local Extra = Switching ? 0 : floor((E:getConstraints():count() - Init)/3)
        MaxTrainBrakeForce = BrakeMul*Extra/(70)
        return Extra
        
    }
    function void array:abRest(){
        
        foreach(K,V:entity = This){
            V:propPhysicalMaterial("phx_tire_normal")
        }
    }
    function void entity:abRelease(){
        local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("friction_00")
        }
    }
   
    
    
    #Misc Init 
    
    Starting = 0
    SQ = 0
    On = 0
    NQ = 0
    DNQ = 0
    TQ = 0
    Notch = 0
    RealNotch = 0
    DynaNotch = -1
    Clag = 0
    RevQ = 0
    DynaQ = 0
    BlendQ = 0
    RLCPT = E = entity()
    O = owner()
    ABQ = 0
    LBQ = 0
    WQ = 0
    BQ = 0
    Mode3Q = 0
    
    
    
    MainRes = 0
    EqualRes = 0
    BrakeLine = 0
    BrakeCyl = 0
    
    #MaxER = AirBrakeType ? 90 : 70
    #AB26L = AirBrakeType ? 45 : 0
    #LB26L = 0
    #TrainBrakePressure = MaxER/2
    LocoBrakePressure = 0
    #ER = 0
    
    BrakeInfo = array(MainRes,EqualRes,BrakeLine,LocoBrakePressure,BrakeCyl)
    
    LB26L_ClickQ = 0
    BPQ = 0
    EMQ = 0
    Locked = 0
    Emergency = 0
    THQ = IHQ = 0
    HBQ = 0
    
    WheelSlipProb = 1/64
    SandQ = 0
    Sanding = 0
    WSQ = 0
    WSC = 0
    
    Trig2 = 0
    OldNotch = 0
    #HEP_Notch = 0
    HEP_Mode = 0
    HEPQ = 0
    
    Switching = 0
    
    
    
    FrontPlugOut = array()
    RearPlugOut = array()
    
    W = E:isWeldedTo()
    
    E:setSubMaterial(2,"debug/env_cubemap_model")
    
    CarCount_Init = E:getConstraints():count()
    
    MaxLocoBrakeForce = 300000/70
    MaxTrainBrakeForce = 0
    
    
    runOnChat(1)
    
    setName("RLC Titanium Beta(Dev and Shomi's edit): "+EngineType+"\n"+LocomotiveType)
}
#=============================
#Startup & Shutdown, Misc Clks
#=============================

MU_Master =!Start

if(changed(Start)){
    E:soundPlay(1001,0,"_jazzlok/switches/relay_02.wav")
}

if(Start&Primer&!On){
    timer("Primer",5000)
    E:soundPlay(1000,0,"_jazzlok/diesel_engines/emd_engines/emd567_prestart2.wav")
}
elseif(Start&!Primer){
    stoptimer("Pimer")    
    soundStop(1000,1)
    Primed=0
}
if(clk("Primer")&Primer){
    stoptimer("Pimer")    
    soundStop(1000,1)
    Primed=1   
}

if(((Primed|(Stop&On)) & !SQ &(BatteryKnifeSwitch&TankLow==0))|(On&TankLow)){
    
    SQ = 1
    Starting = !Starting

    if(Starting){
        
        local Snd = FuelSaver ? (LowIdling ? Startup:sub(1,Startup:length()-4) + "_low.wav" : Startup) : Startup
        W:soundPlay(0,0,Snd)
        timer("run",10*floor(soundDuration(Snd)*50) - 500)
        timer("startclag",StartupClagStart*1000)
        
        if(DPM){
            DPMS = Snd
            timer("dpm",sdr(Snd)-500)
        }
        
    }else{
        On = 0
        Primed=0
        local Snd = FuelSaver ? (LowIdling ? Shutdown:sub(1,Shutdown:length()-4) + "_low.wav" : Shutdown) : Shutdown
        W:soundPlay(0,0,Snd)
        stopAllTimers()
        timer("cool",10*floor(soundDuration(Snd)*50))
        if(DPM){
            DPMS = Snd
            timer("dpm",sdr(Snd))
        }
    }
}elseif(!Primed & SQ){
    SQ = 0
    
}elseif(Primed & !SQ & !On){
print("Error: ")
if(CurrentFuel<=0){print("RLC Titanium Beta - low fuel")}
if(!BatteryKnifeSwitch){print("RLC Titanium Beta - no battery charge, close the knife switch")}
}


if(Starting & clk("run")){
    On = 1
    W:soundPlay(0,0,LowIdling ? LowIdle : Idles[1,string])
    RealNotch = 0
    Notch = 0
    timer("count",5000)
    CarCount = E:extraProps(CarCount_Init)
    if(DPM){
        #print("Run")
        DPMS = LowIdling ? LowIdle : Idles[1,string]
        timer("dpm",sdr(Startup))
    }
    #Compressing = 1
    #W:soundPlay(8,0,CompressorOn)
    #if(!MU_Master){TrainBrakePressure=0}
    
}
if(clk("cool")){
    soundStop(0)
    if(Compressing){
        W:soundPlay(8,2,CompressorOff)
        Compressing = 0
    }
    #ER = 0
        
}elseif(clk("startclag")){
    Clag = 1
    timer("endclag",StartupClagDuration*1000)
}elseif(clk("endclag")){
    Clag = 0
}elseif(clk("count")){
    CarCount = E:extraProps(CarCount_Init)
    
    if(MU_Master){
        MU_OffsetPitch = 0
    }else{
        local CF = (FrontPlugIn:count()>=5)
        local CR = (RearPlugIn:count()>=5)
        MU_OffsetPitch = (CF&CR) ? -2 : 2
    }
    if(!Compressing & (MainRes > 0)){MainRes += -1}
    timer("count",5000)
}elseif(clk("THQ")){
    THQ = 0
    soundStop(5)
}elseif(clk("IHQ")){
    IHQ = 0
    soundStop(5)
}elseif(clk("manclag")){
    RealNotch++
}elseif(clk("WheelSlipEnd")){
    WheelSlip = 0
    soundStop(7)
    WSQ = 1
    timer("WheelSlipStart",500)
}elseif(clk("WheelSlipStart")){
    WSQ = 0
}elseif(clk("mu_recheck")){

    if(DynamicsEnable){
        local MU_Dynamics = FrontPlugIn[4,number] + RearPlugIn[4,number]
        if(MU_Dynamics & !Dynamics){
            Dynamics = 1
        }elseif(!MU_Dynamics & Dynamics){
            Dynamics = 0 
        }
    }
    
    local NotchMU = 0.8*(FrontPlugIn[2,number] + RearPlugIn[2,number])
    
    if(!Dynamics & (Notch!=NotchMU)){
        Notch = NotchMU
        TQ = tq_evaluate(RealNotch,Notch)
        RealNotch = startTransition(RealNotch,Notch)
    }elseif(Dynamics & DynaNotch!=NotchMU){
        DynaNotch = NotchMU
        if(DynamicsEnable==1){
            Notch = DynaNotch>-1 ? DynaNotch : 0
            if(!TQ){
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
    }
}elseif(clk("dpm")){
    DPMH:soundPlay(7,0,DPMS)
    #print(DPMS)
    soundPitch(7,100+DPM_Pitch)
}elseif(clk("highidle")){
    #print("highidle")
    local Snd = Idles[1,string]
    W:soundPlay(0,0,Snd)
    if(DPM & !HEP_Lock){
        DPMS = Snd
        timer("dpm",DPM_Delay)
    }
}elseif(clk("lowidlestart")){
    #print("lowidlestart")
    
    LowIdling = 1
    local Snd = Transition + "down/1-0.wav"
    W:soundPlay(0,0,Snd)
    if(DPM & !HEP_Lock){
        DPMS = Snd
        timer("dpm",DPM_Delay)
    }
    timer("lowidle",sdr(Snd))
}elseif(clk("lowidle")){
    #print("lowidle")
    W:soundPlay(0,0,LowIdle)
    if(DPM & !HEP_Lock){
        DPMS = LowIdle
        timer("dpm",DPM_Delay)
    }
}

#==============
#Engine Running
#==============

#------------------
#Dev's little thing to add in metaldon's fuel e2
#------------------
CurrentFuel=clamp(CurrentFuel,0,TankMax)

if(ReFuel|clk("refuel")){
    timer("refuel",50)
    CurrentFuel += ReFRate
    if(A1==0){
        E:soundPlay(101,0,"ambient/water/water_in_boat1.wav")
        E:soundPlay(102,0,"monkssounds/fuel pumps/fuelpump2.wav")
        A1=1
    }
}
elseif(!ReFuel&!clk("refuel")){
    stoptimer("refuel")       
    soundStop(101,1)
    soundStop(102,1)
    A1=0
}
if(On){if(CurrentFuel > 0){CurrentFuel-=(UseRate*(abs(Notch)/UseMul))+UseRate}}
if(CurrentFuel==TankMax){TankFull=1}else{TankFull=0}
if(CurrentFuel==0){TankLow=1}else{TankLow=0}


if(On){
    interval(50)
    
    if(Trig2){
        Trig2 = 0
        Trig = 1
    }else{
        Trig = 0
    }
    
    #------------------
    #Control Resolution
    #------------------
    
    Driver = Pod:driver()
    
    if(Driver & MU_Master){
        
        local Shifting = Driver:keyPressed(Alternate)
        local Shifting = Driver:keyPressed(Alternate2)
        
        local RF = UsingRearSeat ? "ReverserB" : "ReverserF"
        local RB = UsingRearSeat ? "ReverserF" : "ReverserB"
        
        ReverserF = Driver:keyPressed(Controls[RF,string]) & (Routing[RF,number] ? Shifting : !Shifting)
        ReverserB = Driver:keyPressed(Controls[RB,string]) & (Routing[RB,number] ? Shifting : !Shifting)
        
        IncreaseThrottle = Driver:keyPressed(Controls["IncreaseThrottle",string]) & (Routing["IncreaseThrottle",number] ? Shifting : !Shifting)
        DecreaseThrottle = Driver:keyPressed(Controls["DecreaseThrottle",string]) & (Routing["DecreaseThrottle",number] ? Shifting : !Shifting)
        
        IncreaseTrainBrake = Driver:keyPressed(Controls["IncreaseTrainBrake",string]) & (Routing["IncreaseTrainBrake",number] ? Shifting : !Shifting)
        DecreaseTrainBrake = Driver:keyPressed(Controls["DecreaseTrainBrake",string]) & (Routing["DecreaseTrainBrake",number] ? Shifting : !Shifting)
        
        IncreaseLocoBrake = Driver:keyPressed(Controls["IncreaseLocoBrake",string]) & (Routing["IncreaseLocoBrake",number] ? Shifting : !Shifting)
        DecreaseLocoBrake = Driver:keyPressed(Controls["DecreaseLocoBrake",string]) & (Routing["DecreaseLocoBrake",number] ? Shifting : !Shifting)
        
        if(DynamicsEnable){
            IncreaseDynamics = Driver:keyPressed(Controls["IncreaseDynamics",string]) & (Routing["IncreaseDynamics",number] ? Shifting : !Shifting)
            DecreaseDynamics = Driver:keyPressed(Controls["DecreaseDynamics",string]) & (Routing["DecreaseDynamics",number] ? Shifting : !Shifting)
        }
        EmergencyBrake = Driver:keyPressed(Controls["EmergencyBrake",string]) & (Routing["EmergencyBrake",number] ? Shifting : !Shifting)
        
        HandBrake = Driver:keyPressed(Controls["HandBrake",string]) & (Routing["HandBrake",number] ? Shifting : !Shifting)
        Sander = Sand 
        
    }elseif(!MU_Master){
        #------------
        #MU Receiving
        #------------
        
        if(FrontPlugIn[5,number] | RearPlugIn[5,number]){
            stoptimer("mu_recheck")
            timer("mu_recheck",1000)
            
            Reverser = -FrontPlugIn[1,number] + RearPlugIn[1,number]
            
            
            
            
            
            
            #print("Recv")
            
            
            
            if(DynamicsEnable){
                local MU_Dynamics = FrontPlugIn[4,number] + RearPlugIn[4,number]
                if(MU_Dynamics & !Dynamics){
                    Dynamics = 1
                }elseif(!MU_Dynamics & Dynamics){
                    Dynamics = 0 
                }
            }
            
            local ThrottleMU = FrontPlugIn[2,number] + RearPlugIn[2,number]
            Notch = Dynamics ? Notch : ThrottleMU*0.8
            DynaNotch = Dynamics ? ThrottleMU*0.8 : -1
            
            if(!Dynamics){
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
            
            Sanding = FrontPlugIn[6,number] + RearPlugIn[6,number]
            
        }
    }
    
    #-----------------
    #Engine Sound Code
    #-----------------
    
    #Notch Up By Control
    if(IncreaseThrottle & !NQ & (Notch<8) & !Dynamics){
        NQ = 1
        Notch++
        if(!TQ){
            #TQ = RealNotch==0 ? 0 : 1
            
            
            TQ = tq_evaluate(RealNotch,Notch)
            RealNotch = startTransition(RealNotch,Notch)
            
            
            Pod:soundPlay(1,0.5,Lever_Throttle)
        }
        Trig = 1
    }
    
    if(clk("abu")){
        #print("ab up")
        local Nc = RealNotch:toString()
        local Nn = (RealNotch+1):toString()
        local Snd = Transition + "up/" + Nc + "-" + Nn + "b.wav"
        RealNotch++
        if(!HEP_Lock){W:soundPlay(0,0,Snd)}   
        if((RealNotch < Notch) & (Behavior[RealNotch,number]==0)){
            timer("abu",UpDelays[RealNotch-1,number])
            #print(UpDelays[RealNotch-1,number])
        }else{
            timer("level",sdr(Snd)-50)
            Mode3Q = 0
        }
        
        if(DPM & !HEP_Lock){
            DPMS = Snd
            timer("dpm",DPM_Delay)
        }
    }
    
    #Notch Down By Control
    
    if(DecreaseThrottle & !NQ & (Notch>0) & !Dynamics){
        NQ = 1
        Notch--
        if(!TQ){
            #TQ = RealNotch==1 ? 0 : 1
            
            TQ = tq_evaluate(RealNotch,Notch)
            RealNotch = startTransition(RealNotch,Notch)
            
            Pod:soundPlay(1,0.5,Lever_Throttle)
        }
        Trig = 1
    }
    if(!IncreaseThrottle & !DecreaseThrottle & NQ){
        NQ = 0
    }
    
    if(clk("abd")){
        #print("ab down")
        local Nc = RealNotch:toString()
        local Nn = (RealNotch-1):toString()
        local Snd = Transition + "down/" + Nc + "-" + Nn + "b.wav"
        #print(Snd)
        RealNotch--
        if(!HEP_Lock){W:soundPlay(0,0,Snd)}
        if((RealNotch > Notch) & (Behavior[RealNotch,number]==0)){
            timer("abd",DownDelays[8-RealNotch,number])
            #print(DownDelays[8-RealNotch,number])
        }else{
            timer("level",sdr(Snd)-50)
            Mode3Q = 0
            #print("descending to " + (RealNotch-1))
        }
        
        if(DPM & !HEP_Lock){
            DPMS = Snd
            timer("dpm",DPM_Delay)
        }
    }
    
    #Leveling Out
    if(clk("level")){
        #print("----------------------Leveling at N" + RealNotch + ", Mode3Q = " + Mode3Q)
        if(RealNotch == Notch){
            Clag = 0
            if(!HEP_Lock & !Mode3Q){
                W:soundPlay(0,0,Idles[RealNotch+1,string])
                
            }
            
            Mode3Q = 0
            soundPitch(0,100+MU_OffsetPitch)
            TQ = 0
            #print("levelout")
            if(DPM & !HEP_Lock){
                DPMS = Idles[RealNotch+1,string]
                timer("dpm",DPM_Delay)
            }
            if(HEPQ){
                HEPQ = 0
                HEP_Lock = (HEP_Mode>0)
                Notch = RealNotch = 0
            }
        }else{
            TQ = 1
            RealNotch = startTransition(RealNotch,Notch)
            
            #print("This is what is happening!")
            local BType = Behavior[RealNotch+1,number]
            #print("                            "+BType)
            if(BType>=2){
                W:soundPlay(0,0,Idles[RealNotch+1,string])
            }
            
        }
    }
    
    #Count Clagula V3
    #Clag = Notch > RealNotch
    
    #----------------------------------
    #Shit you have to be in Notch 0 for
    #----------------------------------
    if(RealNotch==0){
        
        #Reverser
        
        if(ReverserF & !RevQ & (Reverser<1) & (!Dynamics)){
            RevQ = 1
            Reverser++
            Pod:soundPlay(1,1,Reverser==1 ? Lever_ReverserF : Lever_ReverserN)
            Trig = 1
        }elseif(ReverserB & !RevQ & (Reverser>-1) & (!Dynamics)){
            RevQ = 1
            Reverser--
            Pod:soundPlay(1,1,Reverser==-1 ? Lever_ReverserB : Lever_ReverserN)
            Trig = 1
        }elseif(!ReverserF & !ReverserB & RevQ){
            RevQ = 0
        }
        
        #Fuel Saver
        if(FuelSaver){
            if((Reverser!=0) & LowIdling){
                LowIdling = 0
                local Snd = Transition + "up/0-1.wav"
                W:soundPlay(0,0,Snd)
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
                timer("highidle",sdr(Snd))
                lowidlestop()
                
            }elseif((Reverser!=0) & !LowIdling & SaverQ){
                lowidlestop()
            
            
            }elseif((Reverser==0) & !LowIdling & !SaverQ){
                
                lowidlestop()
                SaverQ = 1
                timer("lowidlestart",30000)
                #print("                  Starting Timer")
            }
        }
        
        #HEP Switch
        
        if(HEP){
            if(Reverser==0 & !HEPQ){
                if(HEP_Up & (HEP_Mode<2)){
                    HEPQ = 1
                    HEP_Lock = 0
                    HEP_Mode++
                    Notch = HEP_Mode*4
                    TQ = tq_evaluate(Notch-4,Notch)
                    RealNotch = startTransition(Notch-4,Notch)
                    
                    
                }elseif(HEP_Down & (HEP_Mode>0)){
                    HEPQ = 1
                    HEP_Lock = 0
                    HEP_Mode--
                    Notch = HEP_Mode*4  
                    TQ = tq_evaluate(Notch+4,Notch)
                    RealNotch = startTransition(Notch+4,Notch)
                }
            }
        }
    }
    #--------------
    #Dynamic Brakes
    #--------------
    if(DynamicsEnable){
        if(IncreaseDynamics & !DNQ & (DynaNotch<8)){
            #print("blah")
            DNQ = 1
            
            local CanEngage = (DynaNotch==-1) ? (RealNotch==0) : 1
            if((Reverser!=0) & CanEngage){
                DynaNotch++
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1){
                    Notch = DynaNotch
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                }
            }
            Dynamics = DynaNotch > -1
            
        }elseif(DecreaseDynamics & !DNQ & (DynaNotch>-1)){
            DNQ = 1
            
            if(Reverser!=0){
                DynaNotch--
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1){
                    Notch = DynaNotch > -1 ? DynaNotch : 0
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                }
            }
            Dynamics = DynaNotch > -1
        }elseif(!IncreaseDynamics & !DecreaseDynamics & DNQ){
            DNQ = 0
        }
        #Dynamics = DynaNotch > 0
        
        if(Dynamics & !DynaQ){
            DynaQ = 1
            W:soundPlay(2,0,DynoOn)
            if(DynamicsEnable==2){
                Notch = 4
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }elseif(!Dynamics & DynaQ){
            DynaQ = 0
            W:soundPlay(2,7,DynoOff)
            if(DynamicsEnable==2){
                Notch = 0
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
        
    }
    #Blended Braking
    if(DynamicsEnable==3){
        
        local Blend = ((90-BrakeLine)>=10) & (MPH>5)
        #print(MU_Dynamics)
        if(Blend & !BlendQ & (Reverser!=0)){
            BlendQ = 1
            Dynamics = 1
            HEP_Lock = 1
            DynaNotch = 0
            #Pod:soundPlay(1,1,Lever_Throttle)
            #W:soundPlay(2,0,DynoOn)
            #print("Blend on")
            
        }elseif((!Blend | (Reverser==0)) & BlendQ){
            BlendQ = 0
            Dynamics = 0
            DynaNotch = -1
            HEP_Lock = (HEP_Mode>0)
            #W:soundPlay(2,7,DynoOff) 
            #print("Blend Off")
        }
        
    }
    
    #-----------------------
    #Velocity Info Gathering
    #-----------------------
    
    V = -E:velL():z()
    MPH = abs(toUnit("mph",V))
    KPH = abs(toUnit("km/h",V))
    
    Moving = MPH>Threshold_Hard
    #Wheel Sound
    if(Moving){
        if(!WQ){
            WQ = 1
            W:soundPlay(3,0,WheelSound)
        }
        soundPitch(3,MPH*3.3)
    }elseif(!Moving & WQ){
        WQ = 0
        soundStop(3)
    }
    
    
    #----------------------------
    #Instantaneous TE Calculation
    #----------------------------
    
    if(Reverser!=0 & !Dynamics & !HEPQ & (HEP_Mode != 1)){
        local Throttle = min(RealNotch,Notch)
        #local TERAW = 1.5*RealNotch*Horsepower*TECON/(MPH)
        TE = 2*Reverser*TE_Starting*Throttle*exp(-100*MPH/Horsepower)
        
        
        
    }else{
        TE = 0
    }
    
    
    #--------------------------
    #Dynamic Brake Calculations
    #--------------------------
    
    if(Dynamics & DynamicsEnable){
        local Rightway = sign(V)==sign(Reverser)
        local Throttle = DynaNotch
        DynaForce = Reverser*(MPH*MPH)*Throttle*Horsepower*Rightway/16
        
    }else{
        DynaForce = 0
    }
    #==========================
    #Train Brake And Loco Brake
    #==========================
    
    local MU_Connected = (FrontPlugIn:count() + RearPlugIn:count()) > 5
    if(!MU_Master & MU_Connected){
        MainRes = FrontPlugIn[9,number] + RearPlugIn[9,number]
        #EqualRes = 90
        AB16M_Notch = -1
    }
    local NumCompressors = FrontPlugIn[8,number] + RearPlugIn[8,number] + 1
    
    
    
    #----------
    #Compresors
    #----------
    if((MainRes<30) & !Compressing){
        Compressing = 1
        W:soundPlay(8,0,CompressorOn)
    }elseif((MainRes>150) & Compressing){
        Compressing = 0
        W:soundPlay(8,4,CompressorOff)
    }
    if(Compressing){MainRes += 0.5*NumCompressors}
    
    #--------------------
    #Equalizing Reservoir
    #--------------------
    
    if(AirBrakeType){
        #26L Trainline
        if(IncreaseTrainBrake & (EqualRes>0) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_26L)
        }elseif(DecreaseTrainBrake & (EqualRes<90) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_26L)
        }elseif(!DecreaseTrainBrake & !IncreaseTrainBrake & ABQ){
            ABQ = 0
        }
        AB16M_Notch = IncreaseTrainBrake - DecreaseTrainBrake
    }else{
        #16M Trainline
        if(IncreaseTrainBrake & (AB16M_Notch<1) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_16M)
            AB16M_Notch++
        }elseif(DecreaseTrainBrake & (AB16M_Notch>-1) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_16M)
            AB16M_Notch--
        }elseif(!DecreaseTrainBrake & !IncreaseTrainBrake & ABQ){
            ABQ = 0
        }
        
    }
    #ER Hiss
    if((AB16M_Notch==1) & (EqualRes>0) & !THQ){
        THQ = 1
        Pod:soundPlay(5,4,AirBrakeApply)
        timer("THQ",6000)
    }elseif((AB16M_Notch==-1) & (EqualRes<90) & !THQ){
        THQ = 1
        Pod:soundPlay(5,4,AirBrakeRelease)
        timer("THQ",6000)
    }
    #ER Indexing
    if((AB16M_Notch==1) & (EqualRes>0)){
        EqualRes--
    }elseif((AB16M_Notch==-1) & (EqualRes<90)){
        EqualRes++
    }
    #----------
    #Brake Line
    #----------
    if(changed(CarCount) & (($CarCount)>0)){
        BrakeLine *= (CarCount - $CarCount)/CarCount
    }
    if(BrakeLine > EqualRes){
        #Apply
        BrakeLine -= 1/(CarCount/16 + 1)
        
        
    }elseif(BrakeLine < EqualRes){
        #Release
        if(MainRes >= 30){
            MainRes -= 0.125*(CarCount/4 + 1)/NumCompressors
            BrakeLine += 1/(CarCount/16 + 1)
        }
    }
    if(abs(EqualRes-BrakeLine)<=(1/(CarCount/16 + 1))){
        BrakeLine = EqualRes
    }
    
    #----------------
    #Locomotive Brake
    #----------------
    if(AirBrakeType){
        #26L Independent
        LB16M_Notch = IncreaseLocoBrake - DecreaseLocoBrake
        if(IncreaseLocoBrake & (LocoBrakePressure==90) & !LB26L_ClickQ){
            LB26L_ClickQ = 1
            Pod:soundPlay(1,1,Lever_LocoBrake)
        }elseif(LocoBrakePressure<90){
            LB26L_ClickQ = 0
        }
    }else{
        #16M Independent
        if(IncreaseLocoBrake & (LB16M_Notch<1) & !LBQ){
            LBQ = 1
            LB16M_Notch++
            if(LB16M_Notch==1){Pod:soundPlay(1,1,Lever_LocoBrake)}
        }elseif(DecreaseLocoBrake & (LB16M_Notch>-1) & !LBQ){
            LBQ = 1
            LB16M_Notch--
        }elseif(!DecreaseLocoBrake & !IncreaseLocoBrake & LBQ){
            LBQ = 0
        }
    }
    #LB Hiss
    if((LB16M_Notch==-1) & (LocoBrakePressure>0) & !IHQ){
        IHQ = 1
        Pod:soundPlay(5,4,LocoBrakeRelease)
        timer("IHQ",6000)
    }
    
    #LB Indexing
    if((LB16M_Notch==1) & (LocoBrakePressure<90)){
        LocoBrakePressure++
    }elseif((LB16M_Notch==-1) & (LocoBrakePressure>0)){
        LocoBrakePressure--
        
        if(LocoBrakePressure>(90-BrakeLine)){MainRes -= 0.125/NumCompressors}
    }
    
    #Cylinder
    BrakeCyl = max(LocoBrakePressure,90-BrakeLine)/2.5
    
    #Brake Info Array
    BrakeInfo = array(MainRes,EqualRes,BrakeLine,LocoBrakePressure,BrakeCyl)
    
    #Emergency Brake
    if((EmergencyBrake | EmBrake) & !Emergency){
        Emergency = 1
        BrakeLine = 0
        EqualRes = 0
        AB16M_Notch = 2
        
        local Ents = E:getConstraints()
        foreach(K,V:entity=Ents){
            V:propPhysicalMaterial("slipperyslime")
        }
        
        Pod:soundPlay(5,0,EmergencyBrakeSound)
        Pod:soundPlay(1,1,AirBrakeType ? Lever_26L : Lever_16M)
        
        
        Notch = 0
        TQ = tq_evaluate(RealNotch,Notch)
        RealNotch = startTransition(RealNotch,Notch)
        
    }
    
    Brake = (BrakeCyl > 0)
    
    #Brake Screeching Sounds
    local Screech = Moving & Brake & (MPH<8)
    if(Screech & !BQ){
            BQ = 1
        W:soundPlay(4,0,BrakeScreech)
    }elseif(!Screech & BQ){
        BQ = 0
        soundStop(4)
    }
    
    #Train Brake Physprops
    if(Brake & (MPH<Threshold_Hard) & !BPQ){
        BPQ = 1
        Trucks:abRest()
        Locked = 1
        
    }elseif(!Brake & BPQ){
        BPQ = 0
        E:abRelease()
        Locked = 0
        Emergency = 0
        CarCount = E:extraProps(CarCount_Init)
    }
    
    #Handbrake
    if(HandBrake & !HBQ){
        HBQ = 1
        Pod:printDriver("[RLC Pt] Hold key to Apply Handbrakes.")
        timer("HB_Check",1000)
    }elseif(!HandBrake & HBQ){
        HBQ = 0
    }
    
    #Train Brake Force Calculation
    if((MPH>Threshold_Hard)&!Locked){
        if(CarCount<1){
            CarCount = E:extraProps(CarCount_Init)
        }
        local TBF = CarCount*(90-BrakeLine)*MaxTrainBrakeForce
        local LBF = ((90-BrakeLine)>LocoBrakePressure ? (90-BrakeLine) : LocoBrakePressure)*MaxLocoBrakeForce
        BrakingForce = sign(V)*(LBF+TBF)
        
    }else{
        BrakingForce = 0
        #LocoBrakingForce = 0
    }
    

    
    
    #------------------
    #WheelSlip & Sander
    #------------------
    if(Sander & !SandQ){
        SandQ = 1
        Trig = 1
        Sanding = !Sanding
        W:soundPlay(6,Sanding ? 0 : 2, Sanding ? SanderOn : SanderOff)
    }elseif(!Sander & SandQ){
        SandQ = 0
    }
    
    if(ETC!=2 & (Reverser!=0) & !Brake & !Dynamics){
        
        #Sander
#[        if(Sander & !SandQ){
            SandQ = 1
            W:soundPlay(6,0,SanderOn)
            Trig = 1
        }elseif(!Sander & SandQ){
            SandQ = 0
            W:soundPlay(6,2,SanderOff)
            Trig = 1
        }]#
        
        #Wheelslip
        local Throttle = min(RealNotch,Notch)
        if((Throttle>4) & (MPH<10) & !WSQ){
            local SpeedThreshold = (Throttle - 4 - 2*Sanding)*2.5
            
            WheelSlippable = MPH<SpeedThreshold
        }else{
            WheelSlippable = 0
        }
        if(WheelSlippable & !WheelSlip){
            if(random()<(Sanding ? WheelSlipProb/2 : WheelSlipProb)){
                WheelSlip = 1
                local Snd = WSC ? WheelSlipSound1 : WheelSlipSound2
                soundPlay(7,5,Snd)
                WSC = !WSC
                timer("WheelSlipEnd",sdr(Snd))
            }
        }elseif(!WheelSlippable & WheelSlip){
            WheelSlip = 0
            
            stoptimer("WheelSlipEnd")
            soundStop(7,1)
            timer("WheelSlipStart",1000)
        }
        if(WheelSlip){
            local TEMUL = ETC ? 0.5 : 0.25
            TE *= TEMUL
        }
        
        
    }else{
        WheelSlip = 0
        
    }
    
    #=================
    #Force Application
    #=================
    
    Force = TE - BrakingForce - DynaForce 
    W:applyForce(-E:up()*(Force))
    
    Load = (floor(100*(abs(TE) - abs(DynaForce))/(TE_Starting*16)))
    #==============
    #MU Info Output
    #==============
    
    local HP_Forward = Horsepower + RearPlugIn[7,number]
    local HP_Backward = Horsepower + FrontPlugIn[7,number]
    local Comps_Forward = 1 + RearPlugIn[8,number]
    local Comps_Backward  = 1 + FrontPlugIn[8,number] 
    
    if(MU_Master){
        local ThrottleMU = (Dynamics ? DynaNotch : Notch)*1.25
        RearPlugOut = array(-Reverser,ThrottleMU,0,Dynamics,Trig,Sanding,HP_Backward,Comps_Backward,MainRes)
        FrontPlugOut = array(Reverser,ThrottleMU,0,Dynamics,Trig,Sanding,HP_Forward,Comps_Forward,MainRes)
    }else{
        RearPlugOut = FrontPlugIn:clone()
        FrontPlugOut = RearPlugIn:clone()
        
        RearPlugOut[7,number] = HP_Backward
        FrontPlugOut[7,number] = HP_Forward
        
        RearPlugOut[8,number] = Comps_Backward
        FrontPlugOut[8,number] = Comps_Forward
        
    }
    
}



#Handbrake Check
if(clk("HB_Check")){
    if(HandBrake){
        local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("rubber")
        }
        Pod:printDriver("[RLC Pt] Handbrakes Applied.")
        Pod:soundPlay(1,1,Lever_HandBrake)
    }
}

#Lever Unlock Indicator
Unlocked = On&(RealNotch==0)

#=============
#Chat Commands
#=============

if(chatClk(O)|chatClk(Driver)){
    Speaker = lastSpoke()
    LS = lastSaid()
    
    local Sentence = LS:explode(" ")
    local CMD = Sentence[1,string]
    
    switch(CMD){
        case ".engine",
            if(Speaker==O){
                SQ = 1
                
                Starting = (Sentence[2,string]=="") ? !Starting : Sentence[2,string]:toNumber()
                if(Starting){
                    local Snd = FuelSaver ? (LowIdling ? Startup:sub(1,Startup:length()-4) + "_low.wav" : Startup) : Startup
                    W:soundPlay(0,0,Snd)
                    timer("run",10*floor(soundDuration(Snd)*50) - 500)
                    timer("startclag",StartupClagStart*1000)
                    Speaker:printProper("[RLC Pt] Starting Engine.")
                    
                    if(DPM){
                        #print("Run")
                        DPMS = Snd
                        timer("dpm",sdr(Snd))
                    }
                }else{
                    On = 0
                    local Snd = FuelSaver ? (LowIdling ? Shutdown:sub(1,Shutdown:length()-4) + "_low.wav" : Shutdown) : Shutdown
                    W:soundPlay(0,0,Snd)
                    stopAllTimers()
                    timer("cool",10*floor(soundDuration(Snd)*50))
                    Speaker:printProper("[RLC Pt] Shutting Engine Down.")
                    
                    if(DPM){
                        DPMS = Snd
                        timer("dpm",sdr(Snd))
                    }
                }
            }
            hideChat(1)
            break
        case ".notch",
            if(MU_Master & On){
                Notch = clamp(Sentence[2,string]:toNumber(),0,8)
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
                Speaker:printProper("[RLC Pt] Setting Notch to " + Notch:toString() + ".")
                Trig2 = 1
            }elseif(On & !MU_Master){
                stoptimer("mu_recheck")
                timer("mu_recheck",1000)
            }
            hideChat(1)
            break
        case ".brake",
            if(MU_Master & On){
                if(Sentence[2,string]==""){
                    Emergency = 1
                    EqualRes = BrakeLine = 0
                    
                    local Ents = E:getConstraints()
                    foreach(K,V:entity=Ents){
                        V:propPhysicalMaterial("slipperyslime")
                    }
                    AB16M_Notch = 2
                    Pod:soundPlay(5,0,EmergencyBrakeSound)
                    Pod:soundPlay(1,1,AirBrakeType ? Lever_26L : Lever_16M)
                    
                    
                    Notch = 0
                    TQ = tq_evaluate(RealNotch,Notch)
                    RealNotch = startTransition(RealNotch,Notch)
                    Speaker:printProper("[RLC Pt] Applying Emergency Brake.")
                }else{
                    local ToPressure = clamp(Sentence[2,string]:toNumber(),0,90)
                    if(!AirBrakeType){AB16M_Notch = 0}
                    EqualRes = 90-ToPressure
                    Speaker:printProper("[RLC Pt] Setting " + ToPressure:toString() + " lb Application ("+EqualRes:toString()+" ER psi).")
                }
                hideChat(1)
                #Trig2 = 1
            }
            break
        case ".reverser",
            if(MU_Master & On){
                Reverser = clamp(Sentence[2,string]:toNumber(),-1,1)
                Speaker:printProper("[RLC Pt] Setting Reverser to " + Reverser:toString() + ".")
                Trig2 = 1
            }
            hideChat(1)
            break
        case ".dynamics",
            if(On & MU_Master){
                if(DynamicsEnable){
                    local CanEngage = (DynaNotch==0) ? (RealNotch==0) : 1
                    if((Reverser!=0) & CanEngage){
                        
                        DynaNotch = Sentence[2,string]:toNumber()
                        Dynamics = DynaNotch > 0
                        Speaker:printProper("[RLC Pt] Setting Dynamic Brakes to Notch " + Sentence[2,string] + ".")
                    }else{
                        Speaker:printProper("[RLC Pt] Dynamic Brake Condition Invalid!")
                    }
                }else{
                    Speaker:printProper("[RLC Pt] Locomotive has no Dynamic Brakes!")
                }
            }elseif(On & !MU_Master){
                stoptimer("mu_recheck")
                timer("mu_recheck",1000)
            }
            hideChat(1)
            break
        case ".handbrake",
            if(MU_Master){
                local Ents = E:getConstraints()
                foreach(K,V:entity = Ents){
                    V:propPhysicalMaterial("rubber")
                }
                Speaker:printProper("[RLC Pt] Handbrakes Applied.")
                Pod:soundPlay(1,1,Lever_HandBrake)
            }
            hideChat(1)
            break
        case ".controls",
            if(MU_Master){
                for(K=1,ControlPrintOrder:count()){
                    local ControlName = ControlPrintOrder[K,string]
                    local X = Controls[ControlName,string]
                    if(Routing[ControlName,number]){
                        Speaker:printProper(ControlName + ": Shift + " + X)
                    }else{
                        Speaker:printProper(ControlName + ": " + X)
                    }
                }
            }
            hideChat(1)
            break
        case ".superice",
            if(MU_Master){
                E:abRelease()
                Speaker:printProper("[RLC Pt] Consist has been Super Iced.")
            }
            hideChat(1)
            break
        case ".count",
            if(MU_Master){Speaker:printProper("[RLC Pt] Your Train has " + CarCount:toString() + " cars.")}
            hideChat(1)
            break
        case ".weight",
            if(MU_Master){
                local TMass = 0
                local TProps = E:getConstraints()
                for(N=1,TProps:count()){
                    TMass += TProps[N,entity]:mass()
                }
                TMass -= 80000
                local SCE = round(TMass/25000,1)
                Speaker:printProper("[RLC Pt] Total Car Mass: " + SCE:toString() + " SCE.")
            }
            hideChat(1)
            break
        case ".switching",
            if(MU_Master){
                Switching = Sentence[2,string]:toNumber()
                if(Switching){
                    Speaker:printProper("[RLC Pt] Switching Mode Engaged.")
                }else{
                    Speaker:printProper("[RLC Pt] Switching Mode Disengaged.")
                }
                hideChat(1)
            }
            break
        default,
            break
    }
}
if(changed(BatteryKnifeSwitch)&!BatteryKnifeSwitch)
{
    E:soundPlay(104,0,"_jazzlok/switches/buzzer_01.wav") 
    soundVolume(104,0.5)  
    soundStop(103,1)

}
elseif(changed(BatteryKnifeSwitch)&BatteryKnifeSwitch){
    
    E:soundPlay(104,0,"_jazzlok/switches/knife_switch_close.wav") 
    E:soundPlay(103,0,"_jazzlok/switches/hum.wav")  
    soundVolume(103,0.15)
}
if(Clag == 1){
    ConstantClag = 1
}
elseif(Stop == 1){
    ConstantClag = 0
}
