@name RLC Sapphire Beta old as fuck but i'm not upgreading this unit any more.jpeg
@inputs  Stand:entity Start Brakerin MU_Master Pod:entity EmBrake UsingRearSeat Hep_On:number [Trucks FrontPlugIn RearPlugIn RLCSHCoolingarrayin]:array EGPDisplay:wirelink EGPClock:wirelink Slipping
@outputs DecreaseThrottle3 SLippymotherfucker Compressing CompRealnotch Startupdraw MainRes OPS Drain2 Drain1 RealTemp On AP LNumber:string RR:string Reverser DynaNotch Notch RealNotch Brake Dynamics MPH KPH Feet V DynaClag Clag ClagOn ClagString:string LocoBrakePressure Emergency AB16M_Notch LB16M_Notch AB26L LB26L [FrontPlugOut RearPlugOut]:array RLCSHCom1:array CarCount WheelSlip Sanding Unlocked LoadLevel [BrakeInfo RLCSHBrakeInfo RLCSHLights RLCSHNumberPlates RLCSHTrucks RLCSHCoolingarrayout]:array
@persist [Idles Behavior]:array [Transition Startup Shutdown]:string  IdlePitch Notch TargetNotch SQ On NQ TQ [UpDelays DownDelays]:array StartupClagStart RealTemp StartupClagDuration
@persist [DynoOn DynoOff Lever_ReverserF Lever_ReverserN Lever_ReverserB Lever_Throttle Lever_16M Lever_26L]:string ClagString:string IdlePitch2 IdlePitch3 IdlePitch4 IdlePitch5 Sander CarCount2
@persist RevQ DynaQ ServerSideTickRate2 ServerSideTickRate E:entity Starting Dynamics DynamicsEnable DNQ Version:string ClagOn LowidlePitch
@persist [Controls Routing]:table Alternate:string Handbrakeout Loco:string LNumber:string OPS DecreaseThrottle3 SLippymotherfucker
@persist Horsepower TE_Starting W:entity Gearing:string GR Point:vector Letter2:string EGPClock:wirelink Load Loadlevel ClagLevel3 Slipping
@persist AirBrakeType StartupTime ShutdownTime LocoBrakePressure AB16M_Notch LB16M_Notch ABQ [WheelSound BrakeScreech]:string WQ BQ EMQ BPQ CarCount Threshold_Hard Locked LBQ
@persist [AirBrakeApply AirBrakeRelease Lever_LocoBrake LocoBrakeRelease EmergencyBrakeSound]:string THQ IHQ TE 
@persist MaxLocoBrakeForce StepDynaNotch MaxTrainBrakeForce BrakeMul HBQ Lever_HandBrake:string MU_OffsetPitch CarCount_Init O:entity ControlPrintOrder:array
@persist WheelSlipProb ETC [SanderOn SanderOff WheelSlipSound1 WheelSlipSound2]:string SandQ Sanding WSQ WSC Bell ClagLevel2 ClagLevel1
@persist Trig2 OldNotch DPM DPM_Delay DPM_Pitch DPMH:entity DPMS:string HEP AP ClagLevel4 RealNotch2  SoundTest
@persist [CompressorOn CompressorOff]:string ER Compressing MaxER AB26L LB26L LB26L_ClickQ BlendedBraking BlendQ InfiniteAir TRR2 TRR CompRealnotch2 CompRealnotch3 RLCSHCom1:array [CompressorRunning0 CompressorRunning1 CompressorRunning2 CompressorRunning3 CompressorRunning4 CompressorRunning5 CompressorRunning6 CompressorRunning7 CompressorRunning8]:string
@persist MainRes EqualRes BrakeLine BrakeCyl Switching NumPoints S:string I CompRealnotch ShaftDriven RR:string Letter:string [Shutdown1 Shutdown2 CompressorStartGE CompressorStartEMD CompressorRunning CompressorStop]:string
@persist FuelSaver Time Notch4Warming IncreaseThrottle2 DecreaseThrottle2 Warming InThrottle2 [IdleDown IdleUp LowIdle]:string LowIdling Mode3Q SaverQ SplitShutDowns CFG_HourOffset SecondIncrement FuelSaverNew MinuteIncrement HourIncrement SoundNotch AS Compressortype ASrunning
@trigger Start 
@model models/cheeze/beta/white_button.mdl

if(first()|dupefinished()){
    Version="3.4" # Dont's of the touch

   
    
    RR = "ZTTRak" # RailRoad tag info 
    SoundTest =1
    ServerSideTickRate=1 #[ This Makes the sound transistions Smoother on certan servers with odd ball tickrates
    0 = 30 Odball Tickrate for Servrers Running On Non-GUI Unix, Example TS200, LuzRail, BlueTick,
    1 = 33 Tickrate(Most Common) Servers Such as FC&N use this
    2 = 66 Tickrate Most ACF Servers Use This and some Really Half Ass Trainbuild servers
    3 = 128 Tickrate because fuck it, CSGO / PVP type servers use this. (HIGHLY NOT RECOMENDED)]#
    
    # Short Rail Road exaple instead of "Lancing Railroad international" you'd put "LRI
    Loco = "ZTTRak GP38"

    Dev=1  # don't touch please
    


    #[
        Welcome to RLC Sapphire by AlphaGibbon43 (Tyler), Based on Magnum's RLC Platinum V.1.42
        Installation is about the Same as RLCPT v.1.42 you'll figure it out
        All Credit to Magnum For the coding Provided, 

        
    Chat Commands:
    
        .engine - Toggles the Engine.
        .reverser <N> - Changes the Reverser.
        .notch <N> - Changes the engine Notch.
        .brake <N> - Changes the Trainline Brake Pressure. If no argument, applies the Emergency Brake.
        .dynamics <N> - Engages/Disengages the Dynamic Brakes.
        .handbrake - Applies the Handbrake, which gives a rubber physprop to all cars in the consist.
        .controls - Prints the controls to your chat.
        .superice - "super ices" the entire train (Note: actually uses "friction_00").
        .count - Prints the total number of connected cars, assuming 3-prop cars.
        
    Miscellaneous Notes:
    
        The MU System is backwards compatible with RLC, RLC AB, RLC PT, RLC TI, but note the braking code is still a little fucked, I need time to work on that.
        This RLC version is not Recomended to be used on other units that aren't LRI based, RLC Saphire or (RLC SP) has dependency issues and won't like other installs other then what there built on now
        Final note, RLC Sappire is not done. matter of fact it's far from it, i will take bug reports but do not expect help from me to install this on your units, I've given you plenty of warning listed above. 
         
    ]#
    local LocomotiveType = "EMD SW1200" #The Locomotive model designation, for naming purposes.
    local EngineType = "emd645e3v8" #The Engine model, for naming purposes.
    
    Horsepower = 1200 #Horsepower, Please don't make this Excessive
    TE_Starting = 85750 #Starting Tractive effort, in lbf. NOTE: YOU NEED TO DOUBLE THIS COMPARED TO RLCPT OR ELSE YOUR UNIT WILL SLUG UP TO SPEED.
 
    #///////////////////////

    
    Notch4Warming=4
    DynamicsEnable =0 #0 for No Dynamic Braking 
                       #1 for Clutched Fan Cooling Dynamic Braking (OLD EMD Style)
                       #2 idle by Dynanotch (Newer GE)
                       #3 for Notch 4 (ALCO) brakeing
                       #4 for Blended Dynamic Braking (Modern passenger)
                       
      
    ETC = 0 #Electronic Traction Control setting. 0 for no ETC (Hard), 1 for ETC (Easy), 2 to Disable Wheelslip entirely (Lazy).
    
    AS = 1 # Auto Sander 1 For auto sanding on Slip, 0 For no Auto Sand on slip
    
    
    AirBrakeType = 0 #0 for 16M Airbrakes (Harder), 1 for 26L Airbrakes (Broken don't use).
    
    #26L Airbrakes are more modern, and can provide up to 90psi of pressure. The Increase and Decrease keys will add/subtract pressure for as long as you hold them.
    #16M Airbrakes are older. There are three Notches: "Release," "Lap," and "Apply." While in "Release" or "Apply," the
    #brake pressure will continually increase or decrease until it hits the upper or lower limit. In "Lap," the pressure will be held constant.
    
    Gearing = "62:15" #Traction motor Gear Ratio. 62:15 is the standard freight gearing. Larger 1st numbers trade tractive effort for speed.
    
    HEP = 0 #Set this to 1 if the locomotive is equipped for passenger service and uses the Prime Mover as HEP generators.
    DPM = 0 #if 1, will play an additional prime mover sound in addition to the main one
    BrakeMul = 755 #Don't Touch This
    
    #--------------
    #Control Config
    #--------------
    
    #You can actually change this, but be careful.
    #Wiremod key names do not always coincide with source key names!
    
    Alternate = "lshift" #When pressing this key, all controls with "!ALT" next to them will be triggered, and all the other will be ignored.
    
    Controls["ReverserF",string]        = "W"
    Controls["ReverserB",string]        = "S"
    
    Controls["IncreaseThrottle",string] = "D"
    Controls["DecreaseThrottle",string] = "A"	
    
    Controls["IncreaseDynamics",string] = "D !ALT"
    Controls["DecreaseDynamics",string] = "A !ALT"
    
    Controls["IncreaseTrainBrake",string]    = "W !ALT"
    Controls["DecreaseTrainBrake",string]    = "S !ALT"
    
    Controls["IncreaseLocoBrake",string] = "rcontrol"
    Controls["DecreaseLocoBrake",string] = "ralt"
    
    
    Controls["EmergencyBrake",string] = "rshift"
    
    Controls["HandBrake",string] = "H"
    Controls["Sander",string] = "period"
	 

    
    #Ignore this
    ControlPrintOrder = array("ReverserF","ReverserB","IncreaseThrottle","DecreaseThrottle","IncreaseDynamics","DecreaseDynamics","IncreaseTrainBrake","DecreaseTrainBrake","IncreaseLocoBrake","DecreaseLocoBrake","EmergencyBrake","HandBrake","Sander","FrontLights","RearLights","LogoLights","Beacon","Horn","Bell")
    
    
    
    #-----------------
    #Sound/Clag Config
    #-----------------
    
    #You probably shouldn't touch anything below here unless you REALLY know what you're doing.
    
    #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    if(SoundTest){
    StartupTime=7000
    ShutdownTime=0
    Startup = "soldotensoundportspublic/engines/emd645ev8/startup.wav"   #Startup and Shutdown
    Shutdown1 = "soldotensoundportspublic/engines/emd645ev8/shutdown.wav"
    Shutdown2 = "soldotensoundportspublic/engines/emd645ev8/shutdown.wav"  #Startup and Shutdown

    
    StartupClagStart = 0.5    #Clag Config
    StartupClagDuration =3
    
   Idles = array(
    "soldotensoundportspublic/engines/emd645ev8/idle.wav", #Idle
    "soldotensoundportspublic/engines/emd645ev8/notch1.wav", #Notch 1
    "soldotensoundportspublic/engines/emd645ev8/notch2.wav", #Notch 2
    "soldotensoundportspublic/engines/emd645ev8/notch3.wav", #Notch 3
    "soldotensoundportspublic/engines/emd645ev8/notch4.wav", #And so On
    "soldotensoundportspublic/engines/emd645ev8/notch5.wav",
    "soldotensoundportspublic/engines/emd645ev8/notch6.wav",
    "soldotensoundportspublic/engines/emd645ev8/notch7.wav",
    "soldotensoundportspublic/engines/emd645ev8/notch8.wav"
)

Transition = "soldotensoundportspublic/engines/emd645ev8/transitions/"
#---------------------0-1,1-2,2-3,3-4,4-5,5-6,6-7,7-8
Behavior = array(1,  0,  0,  0,  0,  0,  0,  0)
#0 - A/B Notching
#1 - Full Sweep
#2 - Instant Change
#3 - No Change
#4 - Override (Full Sweep)
                #0-1 1-2 2-3   3-4   4-5   5-6   6-7   7-8 
UpDelays = array(2000,  3000,  3505, 3113, 1053, 2596, 2123, 3391)
                  #8-7   7-6   6-5   5-4   4-3   3-2  1-2 1-0
DownDelays = array(3128, 3306, 2272, 3537, 3401, 5006, 3000,  0 )

}else{
  StartupTime=9000
    ShutdownTime=0
Startup = "gsgtrainsounds/emd645v12/startup.wav"   #Startup and Shutdown
    Shutdown1 = "gsgtrainsounds/emd645v12/shutdown.wav"
     Shutdown2 = "gsgtrainsounds/emd645v12/shutdown.wav"
    
  StartupClagStart = 0.5    #Clag Config
    StartupClagDuration =4
    
    Idles = array(                                  #Sounds used for each Notch
    "gsgtrainsounds/emd645v12/idle.wav",
    "gsgtrainsounds/emd645v12/notch1.wav",
    "gsgtrainsounds/emd645v12/notch2.wav",
    "gsgtrainsounds/emd645v12/notch3.wav",
    "gsgtrainsounds/emd645v12/notch4.wav",
    "gsgtrainsounds/emd645v12/notch5.wav",
    "gsgtrainsounds/emd645v12/notch6.wav",
    "gsgtrainsounds/emd645v12/notch7.wav",
    "gsgtrainsounds/emd645v12/notch8.wav"
    )
    Transition = "gsgtrainsounds/emd645v12/transitions/" #The folder path for the transition sounds.
    
                    #1-2  2-3  3-4  4-5  5-6  6-7  7-8 
    UpDelays = array(1500,1800,1200,1200,1000,1200,2500)    #Used for fast notching up/down, don't touch these.
                      #8-7  7-6  6-5  5-4  4-3  3-2  2-1
    DownDelays = array(1600,1600,1600,2000,2000,2000,3300)
    
    Behavior = array(1,  1,  0,  0,  0,  0,  0,  0)
    #0: Normal A/B Notching
    #1: Full Sweep
    #2: Instant Transition
    #3: No Change
    
    #///////////////////////////////////
    
}
    
    #///////////////////////////////////
    IdleDown = "loktrain_sounds/engines/emd645e3bv16/transitions/down/1-0.wav"
    IdleUp = "loktrain_sounds/engines/emd645e3bv16/transitions/up/0-1.wav"
    LowIdle = "loktrain_sounds/engines/emd645e3bv16/idle_low.wav" #Don't touch these unless you know what you are doing!
    FuelSaver = 0
    FuelSaverNew=0
    LowIdling = 0
    SplitShutDowns = 0
    
    DynoOn = " "    #Dynamic Brake Sounds
    DynoOff = " "
    
    Lever_ReverserF = "gsgtrainsounds/misc/desktop/reverser_end.wav"      #Cab Lever Sounds
    Lever_ReverserN = "gsgtrainsounds/misc/desktop/reverser_neutral.wav"
    Lever_ReverserB = "gsgtrainsounds/misc/desktop/reverser_end.wav"
    
    Lever_Throttle = "gsgtrainsounds/misc/desktop/notch_up.wav" 
    
    Lever_16M = "gsgtrainsounds/misc/desktop/notch_down.wav"
    Lever_26L = "gsgtrainsounds/misc/desktop/button_toggle_off.wav"
    
    Lever_LocoBrake = "gsgtrainsounds/misc/desktop/button_toggle_on.wav"
    Lever_HandBrake = "titus's_trainbuild_content_pack_1.1/propper/misc/handbrake02.wav"
    
    WheelSound = "_jazzlok/traction/wheel_joint_loop.wav"     #Wheel Noises
    BrakeScreech = "_jazzlok/brakes/braking04.wav"             #Brake Screech
    
    AirBrakeApply = "titus's_trainbuild_content_pack_1.1/brakes/auto/autobrake01.wav"     #Sounds for Trainline Airbrakes
    AirBrakeRelease = "titus's_trainbuild_content_pack_1.1/brakes/auto/autobrake01.wav"   
    
    LocoBrakeRelease = "titus's_trainbuild_content_pack_1.1/brakes/auto/autobrake13.wav" #Locomotive brakes' apply sounds are very quiet so we just included a release.
    EmergencyBrakeSound = "_jazzlok/brakes/brake_valve_flow_emergency.wav"  #The sound of the engineer shitting his pants
    
    CompressorRunning = "gsgtrainsounds/misc/compressors/gd_wbo_loop.wav"

    CompressorStartGE="loktrain_sounds/compressors/wbo_loop.wav"
    CompressorStartEMD="loktrain_sounds/compressors/wbo_loop.wav"
    CompressorStop="gsgtrainsounds/misc/compressors/gd_wbo_end.wav"
    Compressortype=1
    ShaftDriven=1
    
    SanderOn = "loktrain_sounds/engines/emd645ev12/sw1500sounds/sanderon.wav"    #Not to be confused with Bernie Sanders
    SanderOff = "loktrain_sounds/engines/emd645ev12/sw1500sounds/sanderoff.wav"
    
    WheelSlipSound1 = " "  #Sounds for Wheelslip
    WheelSlipSound2 = " "
    
    Threshold_Hard = 0.25 #Speed, in mph, below which the train brakes will hold the train.
    
    
    DPM_Delay = 200 #Delay in ms for the 2nd prime mover to get the message
    DPM_Pitch = 2 #Extra Pitch to give the 2nd Prime Mover
    
     foreach(K,V:string = Controls){
        if(V:find(" !ALT")){
            Routing[K,number] = 1
            local EXP = V:explode(" ")
            Controls[K,string] = EXP[1,string]
        }else{
            Routing[K,number] = 0
        }
    }
    
    #Sounds Init
    
    #DPM
     if(DPM){
        DPMH = holoCreate(0,entity():isWeldedTo():pos(),vec(1),ang(),vec(255),"cube")
        holoParent(0,entity())
        DPMH:propDraw(0)
        
    }
    
    function void lowidlestop(){
        stoptimer("lowidlestart")
        #print("                Stopping Timer")
        SaverQ = 0
    }
    
    #Tickrate-Adjusted Sound Duration
    function number sdr(Soundpath:string){
        local Tick = round(1/tickInterval())
        
        return floor(soundDuration(Soundpath)*100)*10/((Tick==ServerSideTickRate2) ? 2 : 1)
    }
    
    function number startTransition(From,To){
        lowidlestop()
        
        if(To > From){
            Clag = 1
            
            local BType = Behavior[From+1,number]
             if(LowIdling){
                #LowIdling = 0
                LowIdling = 0
                local Snd = IdleUp
                W:soundPlay(0,0,IdleUp)
                if(DPM){
                    DPMS = IdleUp
                    timer("dpm",DPM_Delay)
                }
                
                timer("level",sdr(Snd))
                
                
                return From+1
            }elseif(BType==1){
              
                local Nc = From:toString()
                local Nn = (From+1):toString()
                local Snd = Transition + "up/" + Nc + "-" + Nn + ".wav"
                                W:soundPlay(0,0,Snd)
                local SDR = sdr(Snd)
                timer("level",SDR)
                timer("manclag",floor(SDR/20)*10)
                Mode3Q = 0
                #print("============Full")
                return From 
                
                if(DPM){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType==0){
                #Normal AB
                local Nc = From:toString()
                local Nn = (From+1):toString()
                local Snd = Transition + "up/" + Nc + "-" + Nn + "a.wav"
                               W:soundPlay(0,0,Snd)
                timer("abu",sdr(Snd)-50)
                return From
                
                if(DPM ){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType>=2){
                timer("level",500)
                if(BType==3){
                    Mode3Q = 1
                }
                return From+1
        }    
            
                
        
        }elseif(To < From){
            Clag = 0
            local BType = Behavior[From,number]
            #print("                                " + BType)
            #Pod:printDriver(BType:toString())
            if(BType==1){
                #Full Sweep
                local Nc = From:toString()
                local Nn = (From-1):toString()
                local Snd = Transition + "down/" + Nc + "-" + Nn + ".wav"
                W:soundPlay(0,0,Snd)
                timer("level",sdr(Snd))
                Mode3Q = 0
                #print("============Full")
                return From-1
                
                if(DPM){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType==0){
                #Normal AB
                local Nc = From:toString()
                local Nn = (From-1):toString()
                local Snd = Transition + "down/" + Nc + "-" + Nn + "a.wav"
              W:soundPlay(0,0,Snd)
                timer("abd",sdr(Snd)-50)
                return From
                
                if(DPM ){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                } 
            }elseif(BType>=2){
                timer("level",500)
                
                if(BType==3){
                    Mode3Q = 1
                }
                return From-1
                
            }
        }else{
            return From
        }
        
    }
    function number tq_evaluate(From,To){
        return    (From!=To)
    }
    function void entity:printProper(Message:string){
        if(This==O){
            print(Message)
        }else{
            Pod:printDriver(Message)
        }
    }
    
    #Locomotive Init
    Notch = 0
    RealNotch = 0
    Reverser = 0
    AB16M_Notch = AirBrakeType ? 0 : 1
    LB16M_Notch = -1
    
    function number entity:extraProps(Init){
        local Extra = Switching ? 0 : floor((E:getConstraints():count() - Init)/3)
        MaxTrainBrakeForce = BrakeMul*Extra/(70)
        return Extra
        
    }
    function void array:abRest(){
        
        foreach(K,V:entity = This){
            V:propPhysicalMaterial("phx_tire_normal")
        }
    }
    function void entity:abRelease(){
        local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("friction_00")
        }
    }
   
    
    
    #Misc Init 
    
    Starting = 0
    SQ = 0
    On = 0
    NQ = 0
    DNQ = 0
    TQ = 0
    Notch = 0
    RealNotch = 0
    DynaNotch = -1
    Clag = 0
    RevQ = 0
    DynaQ = 0
    BlendQ = 0
    RLCPT = E = entity()
    O = owner()
    ABQ = 0
    LBQ = 0
    WQ = 0
    BQ = 0
    Mode3Q = 0
    local GetGears = Gearing:explode(":")
    local GIn = GetGears[1,string]:toNumber()
    local GOut = GetGears[2,string]:toNumber()
    
    local GearRatio = GOut/GIn
    GR = GearRatio*62/15
    
    MainRes = 0
    EqualRes = 0
    BrakeLine = 0
    BrakeCyl = 0
    
    #MaxER = AirBrakeType ? 90 : 70
    #AB26L = AirBrakeType ? 45 : 0
    #LB26L = 0
    #TrainBrakePressure = MaxER/2
    LocoBrakePressure = 0
    #ER = 0
    
    BrakeInfo = array(MainRes,EqualRes,BrakeLine,LocoBrakePressure,BrakeCyl)
    LB26L_ClickQ = 0
    BPQ = 0
    EMQ = 0
    Locked = 0
    Emergency = 0
    THQ = IHQ = 0
    HBQ = 0
    
    WheelSlipProb = 1/32
    SandQ = 0
    Sanding = 0
    WSQ = 0
    WSC = 0
    
    Trig2 = 0
    OldNotch = 0
    #HEP_Notch = 0
    HEP_Mode = 0
    HEPQ = 0
    
    Switching = 0
    
    LowIdling = 0
    
    FrontPlugOut = array()
    RearPlugOut = array()
    
    W = E:isWeldedTo()
    
    E:setSubMaterial(2,"bobsters_trains/br_blue")
    
    CarCount_Init = E:getConstraints():count()
    
    MaxLocoBrakeForce = 300000/70
    MaxTrainBrakeForce = 300000
    
    LNumber = Letter+Letter2
    runOnChat(1)
    
    setName("RLC Sapphire Beta - V."+Version+"\n"+EngineType+"\n"+LocomotiveType+"\n"+RR+" - "+Loco)

}
#=============================
#Startup & Shutdown, Misc Clks
#=============================

if(Start & !SQ){
    SQ = 1
    Starting = !Starting

    if(Starting){
        
        LowIdling = 0
        local Snd = Startup
        W:soundPlay(50,0,Startup)
        timer("startclag",1000*StartupClagStart)
        timer("run",StartupTime)

        
        stoptimer("statsounddelay")

        if(DPM){
            DPMS = Snd
            timer("dpm",sdr(Snd)-500)
        }
     

  
}else{
        On = 0
        FrontPlugOut = array()
        RearPlugOut = array()
        local Snd = Shutdown
        if(LowIdling){
        W:soundPlay(50,0,Shutdown1)
    Shutdown=Shutdown1}else{
        W:soundPlay(50,0,Shutdown2)
    Shutdown=Shutdown2}
        soundStop(0)
        timer("run",10000)
        stopAllTimers()
        timer("cool",10*floor(soundDuration(Snd)*50))
        if(DPM){
            DPMS = Snd
            timer("dpm",sdr(Snd))
        }
    }
}elseif(!Start & SQ){
    SQ = 0
    
}
if(Starting & clk("run")){
    On = 1
    W:soundPlay(0,0,LowIdling ? LowIdle : Idles[1,string])
    RealNotch = 0
    Notch = 0
    timer("count",10000)
    CarCount = E:extraProps(CarCount_Init)
    if(DPM){
        #print("Run")
        DPMS = LowIdling ? LowIdle : Idles[1,string]
        timer("dpm",sdr(Startup))
        
    }
    #Compressing = 1
    #W:soundPlay(8,0,CompressorOn)
    #if(!MU_Master){TrainBrakePressure=0}
    
}
if(clk("cool")){
    soundStop(0)
    if(Compressing){
        W:soundPlay(8,2,CompressorStop)
        Compressing = 0
    }
    #ER = 0
        
}elseif(clk("startclag")){
    Clag = 1
    DynaClag = 1
    timer("endclag",StartupClagDuration*1000)
}elseif(clk("endclag")){
    Clag = 0
    DynaClag = 0
}elseif(clk("count")){
    CarCount = E:extraProps(CarCount_Init)
    
    if(MU_Master){
        MU_OffsetPitch = 0
    }else{
        local CF = (FrontPlugIn:count()>=5)
        local CR = (RearPlugIn:count()>=5)
        MU_OffsetPitch = (CF&CR) ? -2 : 2
    }
    if(!Compressing & (MainRes > 0)){MainRes += -1}
    timer("count",5000)
}elseif(clk("THQ")){
    THQ = 0
    soundStop(5)
}elseif(clk("IHQ")){
    IHQ = 0
    soundStop(5)
}elseif(clk("manclag")){
    RealNotch++
}elseif(clk("WheelSlipEnd")){
    WheelSlip = 0
    soundStop(7)
    WSQ = 1
    timer("WheelSlipStart",500)
}elseif(clk("WheelSlipStart")){
    WSQ = 0
}elseif(clk("mu_recheck")){

    if(DynamicsEnable){
        local MU_Dynamics = FrontPlugIn[4,number] + RearPlugIn[4,number]
        if(MU_Dynamics & !Dynamics){
            Dynamics = 1
        }elseif(!MU_Dynamics & Dynamics){
            Dynamics = 0 
        }
    }
    
    local NotchMU = 0.8*(FrontPlugIn[2,number] + RearPlugIn[2,number])
    
    if(!Dynamics & (Notch!=NotchMU)){
        Notch = NotchMU
        TQ = tq_evaluate(RealNotch,Notch)
        RealNotch = startTransition(RealNotch,Notch)
    }elseif(Dynamics & DynaNotch!=NotchMU){
        DynaNotch = NotchMU
        if(DynamicsEnable==1){
            Notch = DynaNotch>-1 ? DynaNotch : 0
            if(!TQ){
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
    }
}elseif(clk("dpm")){
    DPMH:soundPlay(7,0,DPMS)
    #print(DPMS)
    soundPitch(7,100+DPM_Pitch)
}elseif(clk("highidle")){
    #print("highidle")
    local Snd = Idles[1,string]
    W:soundPlay(0,0,Snd)
    if(DPM){
        DPMS = Snd
        timer("dpm",DPM_Delay)
    }
}elseif(clk("lowidlestart")){
    #print("lowidlestart")
    
    LowIdling = 1
    local Snd = IdleDown
    W:soundPlay(0,0,IdleDown)
    if(DPM){
        DPMS = Snd
        timer("dpm",DPM_Delay)
    }
    timer("lowidle",sdr(Snd))
}elseif(clk("lowidle")){
    #print("lowidle")
    W:soundPlay(0,0,LowIdle)
    if(DPM ){
        DPMS = LowIdle
        timer("dpm",DPM_Delay)
    }
}
if(ServerSideTickRate==0){ServerSideTickRate2=30}
if(ServerSideTickRate==1){ServerSideTickRate2=33}
if(ServerSideTickRate==2){ServerSideTickRate2=66}
if(ServerSideTickRate==3){ServerSideTickRate2=128}
if(Hep_On){soundVolume(11,255)}else{soundVolume(11,0)}

#==============
#Engine Running
#==============


if(On|EqualRes>0|MainRes>0){
    if(Reverser==0){interval(200)
        W:setMass(1500)}
    if(Reverser==1|Reverser==-1){interval(100)
    W:setMass(1000)}

    if(Trig2){
        Trig2 = 0
        Trig = 1
    }else{
        Trig = 0
    }

    if(On&Notch4Warming&RealTemp<60&Reverser==0&Time>2&Notch<2){IncreaseThrottle2=1}
    if(On&Notch4Warming&RealTemp<60&Reverser==0&Time<2){IncreaseThrottle2=0}
    if(On&Notch4Warming&RealTemp>100&Reverser==0&Time>2&Notch>0){DecreaseThrottle2=1}
    if(On&Notch4Warming&RealTemp>100&Reverser==0&Time<2){DecreaseThrottle2=0}
    if(ETC==1&Slipping&Time>2){DecreaseThrottle3=1}
    if(ETC==1&Time<2){DecreaseThrottle3=0}
    #------------------
    #Control Resolution
    #------------------
    
    Driver = Pod:driver()
      
    
        local Shifting = Driver:keyPressed(Alternate)
        local RF = UsingRearSeat ? "ReverserB" : "ReverserF"
        local RB = UsingRearSeat ? "ReverserF" : "ReverserB"
        if(Notch4Warming&RealTemp<150){
        IncreaseThrottle = IncreaseThrottle2
        DecreaseThrottle = DecreaseThrottle2
        }elseif(MU_Master&Driver){
        IncreaseThrottle = Driver:keyPressed(Controls["IncreaseThrottle",string]) & (Routing["IncreaseThrottle",number] ? Shifting : !Shifting)
        DecreaseThrottle = DecreaseThrottle3+Driver:keyPressed(Controls["DecreaseThrottle",string]) & (Routing["DecreaseThrottle",number] ? Shifting : !Shifting)
        }
         if(MU_Master&Driver){ 
        ReverserF = Driver:keyPressed(Controls[RF,string]) & (Routing[RF,number] ? Shifting : !Shifting)
        ReverserB = Driver:keyPressed(Controls[RB,string]) & (Routing[RB,number] ? Shifting : !Shifting)
        
       
        IncreaseTrainBrake = Driver:keyPressed(Controls["IncreaseTrainBrake",string]) & (Routing["IncreaseTrainBrake",number] ? Shifting : !Shifting)
        DecreaseTrainBrake = Driver:keyPressed(Controls["DecreaseTrainBrake",string]) & (Routing["DecreaseTrainBrake",number] ? Shifting : !Shifting)
        
        IncreaseLocoBrake = Driver:keyPressed(Controls["IncreaseLocoBrake",string]) & (Routing["IncreaseLocoBrake",number] ? Shifting : !Shifting)
        DecreaseLocoBrake = Driver:keyPressed(Controls["DecreaseLocoBrake",string]) & (Routing["DecreaseLocoBrake",number] ? Shifting : !Shifting)
        
        if(DynamicsEnable){
            IncreaseDynamics = Driver:keyPressed(Controls["IncreaseDynamics",string]) & (Routing["IncreaseDynamics",number] ? Shifting : !Shifting)
            DecreaseDynamics = Driver:keyPressed(Controls["DecreaseDynamics",string]) & (Routing["DecreaseDynamics",number] ? Shifting : !Shifting)
        }
        EmergencyBrake = Driver:keyPressed(Controls["EmergencyBrake",string]) & (Routing["EmergencyBrake",number] ? Shifting : !Shifting)
        
        HandBrake = Driver:keyPressed(Controls["HandBrake",string]) & (Routing["HandBrake",number] ? Shifting : !Shifting)
        Sander = Driver:keyPressed(Controls["Sander",string]) & (Routing["Sander",number] ? Shifting : !Shifting)
		


    }elseif(!MU_Master){
        #------------
        #MU Receiving
        #------------
        
        if(FrontPlugIn[5,number] | RearPlugIn[5,number]){
            stoptimer("mu_recheck")
            timer("mu_recheck",100)
            
            Reverser = -FrontPlugIn[1,number] + RearPlugIn[1,number]
            
            
            
            print("[RLC Sapphire "+RR+"-"+LNumber+"]: Received Input From Lead Unit")
            
            
            
            if(DynamicsEnable){
                local MU_Dynamics = FrontPlugIn[4,number] + RearPlugIn[4,number]
                if(MU_Dynamics & !Dynamics){
                    Dynamics = 1
                }elseif(!MU_Dynamics & Dynamics){
                    Dynamics = 0 
                }
            }
            
            local ThrottleMU = FrontPlugIn[2,number] + RearPlugIn[2,number]
            Notch = Dynamics ? Notch : ThrottleMU*0.8
            DynaNotch = Dynamics ? ThrottleMU*0.8 : -1
            
            if(!Dynamics){
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
            
            Sanding = FrontPlugIn[6,number] + RearPlugIn[6,number]
            
        }
    }
            
    #-----------------
    #Engine Sound Code
    #-----------------

    
    if(IncreaseThrottle & !NQ & (Notch<8) & !Dynamics){
        NQ = 1
        Notch++
        if(!TQ){
            #TQ = RealNotch==0 ? 0 : 1
            
            
            TQ = tq_evaluate(RealNotch,Notch)
            RealNotch = startTransition(RealNotch,Notch)
            
            
            Pod:soundPlay(1,0.5,Lever_Throttle)
        }
        Trig = 1
    }
    
    if(clk("abu")){
        #print("ab up")
        local Nc = RealNotch:toString()
        local Nn = (RealNotch+1):toString()
        local Snd = Transition + "up/" + Nc + "-" + Nn + "b.wav"
        RealNotch++
        W:soundPlay(0,0,Snd)
        if((RealNotch < Notch) & (Behavior[RealNotch,number]==0)){
            timer("abu",UpDelays[RealNotch-1,number])
            #print(UpDelays[RealNotch-1,number])
        }else{
            timer("level",sdr(Snd)-50)
            Mode3Q = 0
        }
        
        if(DPM ){
            DPMS = Snd
            timer("dpm",DPM_Delay)
        }
    }
    
    #Notch Down By Control
    
    if(DecreaseThrottle & !NQ & (Notch>0) & !Dynamics){
        NQ = 1
        Notch--
        if(!TQ){
            #TQ = RealNotch==1 ? 0 : 1
            
            TQ = tq_evaluate(RealNotch,Notch)
            RealNotch = startTransition(RealNotch,Notch)
            
            Pod:soundPlay(1,0.5,Lever_Throttle)
        }
        Trig = 1
    }
    if(!IncreaseThrottle & !DecreaseThrottle & NQ){
        NQ = 0
    }
    
    if(clk("abd")){
        #print("ab down")
        local Nc = RealNotch:toString()
        local Nn = (RealNotch-1):toString()
        local Snd = Transition + "down/" + Nc + "-" + Nn + "b.wav"
        #print(Snd)
        RealNotch--
        W:soundPlay(0,0,Snd)
        if((RealNotch > Notch) & (Behavior[RealNotch,number]==0)){
            timer("abd",DownDelays[8-RealNotch,number])
            #print(DownDelays[8-RealNotch,number])
        }else{
            timer("level",sdr(Snd)-50)
            Mode3Q = 0
            #print("descending to " + (RealNotch-1))
        }
        
        if(DPM ){
            DPMS = Snd
            timer("dpm",DPM_Delay)
        }
    }
    
    #Leveling Out
    if(clk("level")){
        #print("----------------------Leveling at N" + RealNotch + ", Mode3Q = " + Mode3Q)
        if(RealNotch == Notch){
            Clag = 0
            if( !Mode3Q){
                W:soundPlay(0,0,Idles[RealNotch+1,string])
                
            }
            
            Mode3Q = 0
            soundPitch(0,100+MU_OffsetPitch)
            TQ = 0
            #print("levelout")
            if(DPM){
                DPMS = Idles[RealNotch+1,string]
                timer("dpm",DPM_Delay)
            }
            if(HEPQ){
                HEPQ = 0
                HEP_Lock = (HEP_Mode>0)
                Notch = RealNotch = 0
            }
        }else{
            TQ = 1
            RealNotch = startTransition(RealNotch,Notch)
            
            #print("This is what is happening!")
            local BType = Behavior[RealNotch+1,number]
            #print("                            "+BType)
            if(BType>=2){
                W:soundPlay(0,0,Idles[RealNotch+1,string])
            }
            
        }
    }
    
    #Count Clagula V3
    #Clag = Notch > RealNotch
    
    #----------------------------------
    #Shit you have to be in Notch 0 for
    #----------------------------------
    if(RealNotch==0){
        
        #Reverser
        
        if(ReverserF & !RevQ & (Reverser<1) & (!Dynamics)){
            RevQ = 1
            Reverser++
            Pod:soundPlay(1,1,Reverser==1 ? Lever_ReverserF : Lever_ReverserN)
            Trig = 1
        }elseif(ReverserB & !RevQ & (Reverser>-1) & (!Dynamics)){
            RevQ = 1
            Reverser--
            Pod:soundPlay(1,1,Reverser==-1 ? Lever_ReverserB : Lever_ReverserN)
            Trig = 1
        }elseif(!ReverserF & !ReverserB & RevQ){
            RevQ = 0
        }
        
        #Fuel Saver
if(FuelSaver){
            if((Reverser!=0) & LowIdling){
                LowIdling = 0
                local Snd = IdleUp
                W:soundPlay(0,0,IdleUp)
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
                timer("highidle",sdr(Snd))
                lowidlestop()
                
            }elseif((Reverser!=0) & !LowIdling & SaverQ){
                lowidlestop()
            
            
            }elseif((Reverser==0) & !LowIdling & !SaverQ){
                
                lowidlestop()
                SaverQ = 1
                timer("lowidlestart",10000)
                #print("                  Starting Timer")
            }
        }
        
    }
    #--------------
    #Dynamic Brakes
    #--------------
    if(DynamicsEnable){
        if(IncreaseDynamics & !DNQ & (DynaNotch<8)){
            #print("blah")
            DNQ = 1
            
            local CanEngage = (DynaNotch==-1) ? (RealNotch==0) : 1
            if((Reverser!=0) & CanEngage){
                DynaNotch++
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1){
                    Notch=StepDynaNotch
                  
                    if(!TQ){
                        TQ = tq_evaluate(StepDynaNotch,Notch)
                RealNotch = startTransition(StepDynaNotch,Notch)}
            
         }
                        if(DynamicsEnable==2){
                    Notch=0
                  
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,0)
                RealNotch = startTransition(RealNotch,0)}
            
         }
            }
            Dynamics = DynaNotch > -1
            
        }elseif(DecreaseDynamics & !DNQ & (DynaNotch>-1)){
            DNQ = 1
            
            if(Reverser!=0){
                DynaNotch--
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1){
                    Notch = DynaNotch > -1 ? DynaNotch : 0
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                }
            }
            Dynamics = DynaNotch > -1
        }elseif(!IncreaseDynamics & !DecreaseDynamics & DNQ){
            DNQ = 0
        }
        #Dynamics = DynaNotch > 0
        
        if(Dynamics & !DynaQ){
            DynaQ = 1
            W:soundPlay(2,0,DynoOn)
            if(DynamicsEnable==3){
                Notch = 4
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }elseif(!Dynamics & DynaQ){
            DynaQ = 0
            W:soundPlay(2,7,DynoOff)
            if(DynamicsEnable==2){
                Notch = 0
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
        
    }
    #Blended Braking
    if(DynamicsEnable==4){
        
        local Blend = ((90-BrakeLine)>=10) & (MPH>5)
        #print(MU_Dynamics)
        if(Blend & !BlendQ & (Reverser!=0)){
            BlendQ = 1
            Dynamics = 1
            HEP_Lock = 1
            DynaNotch = 0
            #Pod:soundPlay(1,1,Lever_Throttle)
            #W:soundPlay(2,0,DynoOn)
            #print("Blend on")
            
        }elseif((!Blend | (Reverser==0)) & BlendQ){
            BlendQ = 0
            Dynamics = 0
            DynaNotch = -1
            HEP_Lock = (HEP_Mode>0)
            #W:soundPlay(2,7,DynoOff) 
            #print("Blend Off")
        }
        
    }
    
     #-----------------------
    #Velocity Info Gathering
    #-----------------------
    
    V = -E:velL():z()
    MPH = abs(toUnit("mph",V))
    KPH = abs(toUnit("km/h",V))
    Feet = 10*abs(toUnit("mph",V))
    Moving = MPH>Threshold_Hard
    #Wheel Sound
    if(Moving){
        if(!WQ){
            WQ = 1
            W:soundPlay(3,0,WheelSound)
        }
        soundPitch(3,MPH*3.3)
    }elseif(!Moving & WQ){
        WQ = 0
        soundStop(3)
    }
    
   
    #----------------------------
    #Instantaneous TE Calculation
    #----------------------------
    
  if(Reverser!=0 & !Dynamics & !HEPQ & (HEP_Mode != 1)){
        local Throttle = min(RealNotch2,Notch)
        local TEG = TE_Starting*GR
        local HPG = Horsepower/GR
        TE = 2*Reverser*TEG*Throttle*exp(-100*MPH/HPG)
        #*2*Reverser*TEG*Throttle*exp(-100*MPH/HPG)
        
    }else{
        TE = 0
    }
    
    
    #--------------------------
    #Dynamic Brake Calculations
    #--------------------------
    
    if(Dynamics & DynamicsEnable){
        local Rightway = sign(V)==sign(Reverser)
        local Throttle = DynaNotch
        DynaForce = Reverser*(MPH*MPH)*Throttle*Horsepower*Rightway/16
        
    }else{
        DynaForce = 0
    }
    #==========================
    #Train Brake And Loco Brake
    #==========================
    
    local MU_Connected = (FrontPlugIn:count() + RearPlugIn:count()) > 5
    if(!MU_Master & MU_Connected){
        MainRes = FrontPlugIn[9,number] + RearPlugIn[9,number]
        #EqualRes = 90
        AB16M_Notch = -1
    }
    local NumCompressors = FrontPlugIn[8,number] + RearPlugIn[8,number] + 1
    
    
    
    #----------
    #Compresors
    #----------
if(EqualRes>0&!On){EqualRes--}
if(EqualRes>0&!On){Drain1=1}else{Drain1=0}
if(MainRes>0&!On){MainRes--}
if(MainRes>0&!On){Drain2=1}else{Drain2=0}
if(Compressortype==0){
    if((MainRes<120&On) & !Compressing){
        Compressing = 1
        W:soundPlay(40,2,CompressorStartGE)
    timer("compdelay",500)}
        elseif(clk("compdelay")){


stoptimer("compdelay")


        
    }elseif((MainRes>150) & Compressing){
        Compressing = 0
        W:soundPlay(8,4,CompressorStop)

        
    }
    if(Compressing){MainRes += 0.5+0.5*NumCompressors*CompRealnotch/CarCount2}
}
if(Compressortype==1){
    if((MainRes<120&On) & !Compressing){
        Compressing = 1
        W:soundPlay(40,1,CompressorStartEMD)
      
    timer("compdelay",500)}
        elseif(clk("compdelay")){
W:soundPlay(8,0,CompressorRunning)

stoptimer("compdelay")

        
    }elseif((MainRes>150) & Compressing){
        Compressing = 0
        W:soundPlay(8,10,CompressorStop)
 


    }
    if(Compressing){MainRes += 0.5+0.5*NumCompressors*CompRealnotch/CarCount2}
}
    #--------------------
    #Equalizing Reservoir
    #--------------------
    
    if(AirBrakeType){
        #26L Trainline
        if(IncreaseTrainBrake & (EqualRes>0) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_26L)
        }elseif(DecreaseTrainBrake & (EqualRes<90) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_26L)
        }elseif(!DecreaseTrainBrake & !IncreaseTrainBrake & ABQ){
            ABQ = 0
        }
        AB16M_Notch = IncreaseTrainBrake - DecreaseTrainBrake
    }else{
        #16M Trainline
        if(IncreaseTrainBrake & (AB16M_Notch<1) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_16M)
            AB16M_Notch++
        }elseif(DecreaseTrainBrake & (AB16M_Notch>-1) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_16M)
            AB16M_Notch--
        }elseif(!DecreaseTrainBrake & !IncreaseTrainBrake & ABQ){
            ABQ = 0
        }
        
    }
    #ER Hiss
    if((AB16M_Notch==1) & (EqualRes>0) & !THQ){
        THQ = 1
        Pod:soundPlay(5,4,AirBrakeApply)
        timer("THQ",6000)
    }elseif((AB16M_Notch==-1) & (EqualRes<90) & !THQ){
        THQ = 1
        Pod:soundPlay(5,4,AirBrakeRelease)
        timer("THQ",6000)
    }
    #ER Indexing
    if((AB16M_Notch==1) & (EqualRes>0)){
        EqualRes--
    }elseif((AB16M_Notch==-1) & (EqualRes<90)){
        EqualRes++
    }
    #----------
    #Brake Line
    #----------
    if(changed(CarCount) & (($CarCount)>0)){
        BrakeLine *= (CarCount - $CarCount)/CarCount
    }
    if(BrakeLine > EqualRes){
        #Apply
        BrakeLine -= 1/(CarCount/16 + 1)
        
        
    }elseif(BrakeLine < EqualRes){
        #Release
        if(MainRes >= 30){
            MainRes -= 0.125*(CarCount/4 + 1)/NumCompressors
            BrakeLine += 1/(CarCount/16 + 1)
        }
    }
    if(abs(EqualRes-BrakeLine)<=(1/(CarCount/16 + 1))){
        BrakeLine = EqualRes
    }
    
    #----------------
    #Locomotive Brake
    #----------------
    if(AirBrakeType){
        #26L Independent
        LB16M_Notch = IncreaseLocoBrake - DecreaseLocoBrake
        if(IncreaseLocoBrake & (LocoBrakePressure==90) & !LB26L_ClickQ){
            LB26L_ClickQ = 1
            Pod:soundPlay(1,1,Lever_LocoBrake)
        }elseif(LocoBrakePressure<90){
            LB26L_ClickQ = 0
        }
    }else{
        #16M Independent
        if(IncreaseLocoBrake & (LB16M_Notch<1) & !LBQ){
            LBQ = 1
            LB16M_Notch++
            if(LB16M_Notch==1){Pod:soundPlay(1,1,Lever_LocoBrake)}
        }elseif(DecreaseLocoBrake & (LB16M_Notch>-1) & !LBQ){
            LBQ = 1
            LB16M_Notch--
        }elseif(!DecreaseLocoBrake & !IncreaseLocoBrake & LBQ){
            LBQ = 0
        }
    }
    #LB Hiss
    if((LB16M_Notch==-1) & (LocoBrakePressure>0) & !IHQ){
        IHQ = 1
        Pod:soundPlay(5,4,LocoBrakeRelease)
        timer("IHQ",6000)
    }
    
    #LB Indexing
    if((LB16M_Notch==1) & (LocoBrakePressure<90)){
        LocoBrakePressure++
    }elseif((LB16M_Notch==-1) & (LocoBrakePressure>0)){
        LocoBrakePressure--
        
        if(LocoBrakePressure>(90-BrakeLine)){MainRes -= 0.125/NumCompressors}
    }
    
    #Cylinder
    BrakeCyl = max(LocoBrakePressure,90-BrakeLine)/2.5
    
    #Brake Info Array
    BrakeInfo = array(MainRes,EqualRes,BrakeLine,LocoBrakePressure,BrakeCyl)
    
    #Emergency Brake
    if((EmergencyBrake | EmBrake) & !Emergency){
        Emergency = 1
        BrakeLine = 0
        EqualRes = 0
        AB16M_Notch = 2
        
        local Ents = E:getConstraints()
        foreach(K,V:entity=Ents){
            V:propPhysicalMaterial("slipperyslime")
        }
        
        Pod:soundPlay(5,0,EmergencyBrakeSound)
        Pod:soundPlay(1,1,AirBrakeType ? Lever_26L : Lever_16M)
        
        
        Notch = 0
        TQ = tq_evaluate(RealNotch,Notch)
        RealNotch = startTransition(RealNotch,Notch)
        
        Trig = 1
    }
    
    Brake = (BrakeCyl > 0)
    
    #Brake Screeching Sounds
    local Screech = Moving & Brake & (MPH<8)
    if(Screech & !BQ){
            BQ = 1
        W:soundPlay(4,0,BrakeScreech)
    }elseif(!Screech & BQ){
        BQ = 0
        soundStop(4)
    }
    
    #Train Brake Physprops
    if(Brake & (MPH<Threshold_Hard) & !BPQ){
        BPQ = 1
        Trucks:abRest()
        Locked = 1
        
    }elseif(!Brake & BPQ){
        BPQ = 0
        E:abRelease()
        Locked = 0
        Emergency = 0
        CarCount = E:extraProps(CarCount_Init)
    }
    
    #Handbrake
    if(HandBrake & !HBQ){
        HBQ = 1
        Pod:printDriver("[RLC Sapphire "+RR+" - "+LNumber+"]: Hold key to Apply Handbrakes.")
        timer("HB_Check",1000)
    }elseif(!HandBrake & HBQ){
        HBQ = 0
    }
    
    #Train Brake Force Calculation
    if((MPH>Threshold_Hard)&!Locked){
        if(CarCount<1){
            CarCount = E:extraProps(CarCount_Init)
        }
        local TBF = CarCount*(90-BrakeLine)*MaxTrainBrakeForce
        local LBF = ((90-BrakeLine)>LocoBrakePressure ? (90-BrakeLine) : LocoBrakePressure)*MaxLocoBrakeForce
        BrakingForce = sign(V)*(LBF+TBF)
        
    }else{
        BrakingForce = 0
        #LocoBrakingForce = 0
    }
    
    #------------------
    #WheelSlip & Sander
    #------------------
    if(Sander & !SandQ){
        SandQ = 1
        Trig = 1
        Sanding = !Sanding
        W:soundPlay(6,Sanding ? 0 : 2, Sanding ? SanderOn : SanderOff)
    }elseif(!Sander & SandQ){
        SandQ = 0
    }
    
    if(ETC!=2 & (Reverser!=0) & !Brake & !Dynamics){
        
        #Sander
#[        if(Sander & !SandQ){
            SandQ = 1
            W:soundPlay(6,0,SanderOn)
            Trig = 1
        }elseif(!Sander & SandQ){
            SandQ = 0
            W:soundPlay(6,2,SanderOff)
            Trig = 1
        }]#
        
        #Wheelslip
        local Throttle = min(RealNotch,Notch)
        if((Throttle>4) & (MPH<10) & !WSQ){
            local SpeedThreshold = (Throttle - 4 - 2*Sanding)*2.5
            
            WheelSlippable = MPH<SpeedThreshold
        }else{
            WheelSlippable = 0
        }
        if(WheelSlippable&Brakerin==-2& !WheelSlip){
            if(random()<(Sanding ? WheelSlipProb/2 : WheelSlipProb)){
                WheelSlip = 1
                local Snd = WSC ? WheelSlipSound1 : WheelSlipSound2
                soundPlay(7,5,Snd)
                WSC = !WSC
                timer("WheelSlipEnd",sdr(Snd))
            }
        }elseif(!WheelSlippable & WheelSlip){
            WheelSlip = 0
            
            stoptimer("WheelSlipEnd")
            soundStop(7,1)
            timer("WheelSlipStart",1000)
        }
        if(WheelSlip){
            local TEMUL = ETC ? 0.5 : 0.25
            TE *= TEMUL
        }
        
        
    }else{
        WheelSlip = 0
        
    }
    
    #=================
    #Force Application
    #=================
    Force = TE - BrakingForce*2 - DynaForce 
       if(Brakerin==-2){W:applyForce(-E:up()*(Force))
Load = (floor(100*(abs(TE) - abs(DynaForce))/(TE_Starting*16)))}else{Load = 0}
   
        
    
 
    #==============
    #MU Info Output
    #==============
    
    local HP_Forward = Horsepower + RearPlugIn[7,number]
    local HP_Backward = Horsepower + FrontPlugIn[7,number]
    local Comps_Forward = 1 + RearPlugIn[8,number]
    local Comps_Backward  = 1 + FrontPlugIn[8,number] 
    
    if(MU_Master){
        local ThrottleMU = (Dynamics ? DynaNotch : Notch)*1.25
        RearPlugOut = array(-Reverser,ThrottleMU,0,Dynamics,Trig,Sanding,HP_Backward,Comps_Backward,MainRes)
        FrontPlugOut = array(Reverser,ThrottleMU,0,Dynamics,Trig,Sanding,HP_Forward,Comps_Forward,MainRes)
    }else{
        RearPlugOut = FrontPlugIn:clone()
        FrontPlugOut = RearPlugIn:clone()
        
        RearPlugOut[7,number] = HP_Backward
        FrontPlugOut[7,number] = HP_Forward
        
        RearPlugOut[8,number] = Comps_Backward
        FrontPlugOut[8,number] = Comps_Forward
        
    }
    
}
       OPS=ops()
    if(ClagLevel2+ClagLevel1+ClagLevel3>7){ClagLevel4=8}else{
    ClagLevel4=ClagLevel2+ClagLevel1+ClagLevel3}

    ClagString="clag_2stroke_"+ClagLevel4
    
    if(Notch>RealNotch){ClagLevel1=1}
    if(Notch-RealNotch>1& Clag){ClagLevel1=2}
    if(Notch-RealNotch>2& Clag){ClagLevel1=2}
    if(Notch-RealNotch>3& Clag){ClagLevel1=3}
    if(Notch-RealNotch>4& Clag){ClagLevel1=3}
    if(Starting|On){ClagOn=1}else{ClagOn=0}
    if(Clag){ClagLevel2=1}
    if(!Clag){ClagLevel2=0}
    if(Load < 20 & Load>10){ClagLevel2=1}
    if(Load < 30 & Load > 19){ClagLevel2=2}
    if(Load > 29){ClagLevel2=3}
    if(Load < -30){DynaClag=1} else{DynaClag = 0 }
    if(DynamicsEnable==1){   
    if(Dynamics&DynaNotch<6){StepDynaNotch=2}
    if(DynaNotch==7){StepDynaNotch=3}
    if(DynaNotch==8){StepDynaNotch=4}}
    if(ShaftDriven==1){soundPitch(8,80+CompRealnotch*10)
    if(RealNotch<CompRealnotch){CompRealnotch-=0.1}
    if(RealNotch>CompRealnotch){CompRealnotch+=0.1}}
    if(ShaftDriven==2){soundPitch(8,100+5*CompRealnotch)
    if(RealNotch>1|Reverser==0){REsp=1}else{REsp=0}
    if(RealNotch>CompRealnotch){CompRealnotch+=0.05}
    if(RealNotch<CompRealnotch){CompRealnotch-=0.05}
}

    if(CarCount>36){CarCount2=128}else{CarCount2=CarCount+24}
    if(Compressing&!ShaftDriven){soundPitch(8,100)}
    if(Starting|On){AP=1}else{AP=0}
    RLCSHTrucks = array(Load,MPH,Dynamics,SLippymotherfucker,BrakeCyl,Reverser)
    RLCSHCom1 = array(MU_Master,Reverser,Notch,Dynamics,DynaNotch,LocoBrakeRelease,LB16M_Notch,AB16M_Notch,MPH,LoadLevel,RealTemp)
    if(RealTemp<80&RealTemp>0){ClagLevel3=2}
    if(RealTemp<120&RealTemp>79){ClagLevel3=1}
    if(RealTemp<150&RealTemp>119){ClagLevel3=0}
    if(RealTemp>149){ClagLevel3=0}
    if(Load<20&RealNotch>1){IdlePitch3=0}
    if(Load>20&Load<40&RealNotch>1){IdlePitch3=2}
    if(Load>40&Load<60&RealNotch>1){IdlePitch3=4}
    if(Load>60&Load<80&RealNotch>1){IdlePitch3=6}
    if(Load>80&Load<90&RealNotch>1){IdlePitch3=8}
    if(Load>90&Load<100&RealNotch>1){IdlePitch3=10}
    if(Load>100&RealNotch>1){IdlePitch3=12}
    if(RealNotch>0&RealNotch<3&Reverser!=0){IdlePitch3=3}
    if(RealNotch==0){IdlePitch3=0}
    if(RealNotch>RealNotch2&Notch==RealNotch){RealNotch2+=0.5}
    if(RealNotch<RealNotch2&Notch==RealNotch){RealNotch2=RealNotch}
    RLCSHCoolingarrayout=array(On,RealTemp)
    if(IdlePitch3>IdlePitch5){IdlePitch5++}
    if(IdlePitch3<IdlePitch5){IdlePitch5--}
    if(On&RealTemp>149){RealTemp+=0.1}
    if(On&RealTemp<150){RealTemp+=0.2}
    if(On&RealNotch>0){RealTemp+=0.2*RealNotch}
    if(On){RealTemp-=RLCSHCoolingarrayin[1,number]}
    if(Load>LoadLevel){LoadLevel++}
    if(Load<LoadLevel){LoadLevel--}
    soundPitch(0,100-IdlePitch5+IdlePitch)
    soundPitch(50,100-IdlePitch5+IdlePitch)
    if(Starting&Clag&!On){Startupdraw=1}else{Startupdraw=0}
    if(FuelSaverNew==1&RealTemp>150&Reverser==0&RealNotch==0&On&IdlePitch<15){IdlePitch++
    soundStop(50)}elseif(IdlePitch>0){IdlePitch-=2}
    if(RealTemp<150){Warming=1}else{Warming=0}
      if(RealTemp<50){Time++}
    if(RealTemp>50){Time++}
        if(Time>3){Time=0}
    if(WheelSlip){ SLippymotherfucker=1 timer("slipp",3000)}
     if(clk("slipp")){SLippymotherfucker=0}
if(On){soundStop(50)}
if(WheelSlip&AS==1&!SandQ&On&!Sanding){SandQ = 1
Trig = 1
ASrunning=1
Sanding = 1
W:soundPlay(6,0,SanderOn)
}
if(AS==1&On&Sanding&ASrunning==1&Notch<4){SandQ = 0
Trig = 1
ASrunning=0
Sanding = 0
W:soundPlay(6,0,SanderOff)
}
if(Brake&MPH<1){
            local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("rubber")
            }
        }else{  local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
        V:propPhysicalMaterial("super_ice")}
}


#Handbrake Check
if(clk("HB_Check")){
    if(HandBrake){
        local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("rubber")
            Handbrakeout=1
        }
        Pod:printDriver("[RLC Sapphire "+RR+" - "+LNumber+"]: Handbrakes Applied.")
        Pod:soundPlay(1,1,Lever_HandBrake)
    
    }
}

#Lever Unlock Indicator
Unlocked = On&(RealNotch==0)
if(Brake==0){Handbrakeout=0}
LoadLevel
#=============
#Chat Commands
#=============

if(chatClk(O)|chatClk(Driver)){
    Speaker = lastSpoke()
    LS = lastSaid()
    
    local Sentence = LS:explode(" ")
    local CMD = Sentence[1,string]
    
    switch(CMD){
        case ".engine"+RR+LNumber,
            if(Speaker==O){
                SQ = 1
                
                Starting = (Sentence[2,string]=="") ? !Starting : Sentence[2,string]:toNumber()
                if(Starting){
                    local Snd = (FuelSaver & SplitShutDowns) ? (LowIdling ? Startup:sub(1,Startup:length()-4) + "_low.wav" : Startup) : Startup
                 W:soundPlay(50,0,Startup)
                   timer("run",StartupTime)
                    timer("startclag",1000*StartupClagStart)
                    Speaker:printProper("[RLC Sapphire "+RR+"-"+LNumber+"]: Starting Engine.")
                    
                    if(DPM){
                        #print("Run")
                        DPMS = Snd
                        timer("dpm",sdr(Snd))
                    }
                }else{
                    On = 0
                    local Snd = Shutdown
                    if(LowIdling){
                    W:soundPlay(50,0,Shutdown1)
                    Shutdown=Shutdown1}else{
                    W:soundPlay(50,0,Shutdown2)
                    Shutdown=Shutdown2}
                    soundStop(0)
                    stopAllTimers()
                    timer("run",10000)
                    Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Shutting Engine Down.")
                    
                    if(DPM){
                        DPMS = Snd
                        timer("dpm",sdr(Snd))
                    }
                }
            }
            hideChat(1)
            break
        case ".notch"+RR+LNumber,
            if(MU_Master & On){
                Notch = clamp(Sentence[2,string]:toNumber(),0,8)
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
                Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Setting Notch to " + Notch:toString() + ".")
                Trig2 = 1
            }elseif(On & !MU_Master){
                stoptimer("mu_recheck")
                timer("mu_recheck",1000)
            }
            hideChat(1)
            break
        case ".brake"+RR+LNumber,
            if(On){
                if(Sentence[2,string]==""){
                    Emergency = 1
                    EqualRes = BrakeLine = 0
                    
                    local Ents = E:getConstraints()
                    foreach(K,V:entity=Ents){
                        V:propPhysicalMaterial("slipperyslime")
                    }
                    AB16M_Notch = 2
                    Pod:soundPlay(5,0,EmergencyBrakeSound)
                    Pod:soundPlay(1,1,AirBrakeType ? Lever_26L : Lever_16M)
                    
                    
                    Notch = 0
                    TQ = tq_evaluate(RealNotch,Notch)
                    RealNotch = startTransition(RealNotch,Notch)
                    Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Oh fuck Applying Emergency Brake.")
                    Trig2 = 1
                }else{
                    local ToPressure = clamp(Sentence[2,string]:toNumber(),0,90)
                    if(!AirBrakeType){AB16M_Notch = 0}
                    EqualRes = 90-ToPressure
                    Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Setting " + ToPressure:toString() + " lb Application ("+EqualRes:toString()+" ER psi).")
                }
                hideChat(1)
                #Trig2 = 1
            }
            break
        case ".reverser"+RR+LNumber,
            if(MU_Master & On){
                Reverser = clamp(Sentence[2,string]:toNumber(),-1,1)
                Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Setting Reverser to " + Reverser:toString() + ".")
                Trig2 = 1
            }
            hideChat(1)
            break
        case ".dynamics"+RR+LNumber,
            if(On & MU_Master){
                if(DynamicsEnable){
                    local CanEngage = (DynaNotch==0) ? (RealNotch==0) : 1
                    if((Reverser!=0) & CanEngage){
                        
                        DynaNotch = Sentence[2,string]:toNumber()
                        Dynamics = DynaNotch > 0
                        Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Setting Dynamic Brakes to Notch " + Sentence[2,string] + ".")
                    }else{
                        Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]:Dynamic Brake Condition Invalid.. set the reverser first dumb ass")
                    }
                }else{
                    Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Oh it would seem Your Locomotive has no Dynamic Brakes. Your fucked XD")
                }
            }elseif(On & !MU_Master){
                stoptimer("mu_recheck")
                timer("mu_recheck",1000)
            }
            hideChat(1)
            break
        case ".handbrake"+RR+LNumber,
            if(MU_Master){
                local Ents = E:getConstraints()
                foreach(K,V:entity = Ents){
                    V:propPhysicalMaterial("rubber")
                }
                Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Handbrakes Applied.")
                Pod:soundPlay(1,1,Lever_HandBrake)
            }
            hideChat(1)
            break
        case ".controls"+RR+LNumber,
            if(MU_Master){
                for(K=1,ControlPrintOrder:count()){
                    local ControlName = ControlPrintOrder[K,string]
                    local X = Controls[ControlName,string]
                    if(Routing[ControlName,number]){
                        Speaker:printProper(ControlName + ": Shift + " + X)
                    }else{
                        Speaker:printProper(ControlName + ": " + X)
                    }
                }
            }
            hideChat(1)
            break
        case ".superice"+RR+LNumber,
            if(MU_Master){
                E:abRelease()
                Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Consist has been Super Iced.")
            }
            hideChat(1)
            break
        case ".count"+RR+LNumber,
            if(MU_Master){Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Your Train has " + CarCount:toString() + " cars.")}
            hideChat(1)
            break
        case ".weight"+RR+LNumber,
            if(MU_Master){
                local TMass = 0
                local TProps = E:getConstraints()
                for(N=1,TProps:count()){
                    TMass += TProps[N,entity]:mass()
                }
                TMass -= 80000
                local SCE = round(TMass/25000,1)
                Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Total Car Mass: " + SCE:toString() + " SCE.")
            }
            hideChat(1)
            break
        case ".switching"+RR+LNumber,
            if(MU_Master){
                Switching = Sentence[2,string]:toNumber()
                if(Switching){
                    Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Switching Mode Engaged.")
                }else{
                    Speaker:printProper("[RLC Sapphire "+RR+" - "+LNumber+"]: Switching Mode Disengaged.")
                }
                hideChat(1)
            }
            break
        default,
            break
    }
}

if(!On){
timer("offrefresh",1000)
if(EqualRes>0&!On){EqualRes-- Drain1=1}else{Drain1=0}
if(MainRes>0&!On){MainRes-- Drain2=1}else{Drain2=0}
if(RealTemp>32&!On){RealTemp-=0.2}
}


if(dupefinished()|first()){
if(Dev){hint("You are using Version "+Version+" of RLC Sapphire, This is a Dev / Concersion Version and should not be used as a Release canidate",7)}
RealTemp=0
 LNumber = "A"+randint(100,160):toString() #Random Number Generator
    
  print("[RLC Sapphire "+RR+"-"+LNumber+"]: Unit: "+Loco+" - "+LNumber+" Is now done spawning.")


    #[ [Configuration] ]#
    CFG_HourOffset = 8
   
    #[ [EGP] ]#
    EGPClock:egpClear()
   
    EGPClock:egpBox(1,vec2(256,256),vec2(512,512))
    EGPClock:egpColor(1,vec(0,0,0))
   
    EGPClock:egpBox(2,vec2(256,256),vec2(512,512))
    EGPClock:egpColor(2,vec(33,33,33))
    EGPClock:egpMaterial(2,"gui/gradient_up")
   
    EGPClock:egpCircle(3,vec2(256,256),vec2(192,192))
    EGPClock:egpColor(3,vec(44,44,44))
   
    EGPClock:egpCircle(4,vec2(256,256),vec2(182,182))
    EGPClock:egpColor(4,vec(66,66,66))
   
    EGPClock:egpBox(5,vec2(0,-56),vec2(2,182 - 32))
    EGPClock:egpColor(5,vec(128,128,128))
   
    EGPClock:egpCircle(7,vec2(256,256),vec2(16,16))
    EGPClock:egpColor(7,vec(44,44,44))
    EGPClock:egpParent(5,7)
   
    EGPClock:egpBox(8,vec2(0,-36),vec2(4,182 - 64))
    EGPClock:egpColor(8,vec(128,128,128))
    EGPClock:egpCircle(9,vec2(256,256),vec2(16,16))
    EGPClock:egpColor(9,vec(44,44,44))
    EGPClock:egpParent(8,9)
   
    EGPClock:egpBox(10,vec2(0,-12),vec2(6,182 - 96))
    EGPClock:egpColor(10,vec(128,128,128))
    EGPClock:egpCircle(11,vec2(256,256),vec2(16,16))
    EGPClock:egpColor(11,vec(44,44,44))
    EGPClock:egpParent(10,11)
   
    EGPClock:egpCircle(11,vec2(256,256),vec2(16,16))
    EGPClock:egpColor(30,vec(44,44,44))
    
    FirstPos = vec2(256,256 - 162)
    EGPClock:egpText(12,"12",FirstPos)
    EGPClock:egpSize(12,30)
    EGPClock:egpColor(12,vec(128,128,128))
    EGPClock:egpAlign(12,1,1)
   
    NumPoints = 1
   
    for(I = 30,360,30)
    {
        Point = vec(FirstPos:x(),FirstPos:y(),512*512):rotateAroundAxis(vec(256,256,512*512),I)
        EGPClock:egpText(EGPClock:egpNumObjects() + 2,NumPoints:toString(),vec2(Point))
        EGPClock:egpSize(EGPClock:egpNumObjects() + 1,30)
        EGPClock:egpColor(EGPClock:egpNumObjects() + 1,vec(128,128,128))
        EGPClock:egpAlign(EGPClock:egpNumObjects() + 1,1,1)
        NumPoints++}

}

EGPClock:egpAngle(7,(360 -  (SecondIncrement * time("sec"))))
EGPClock:egpAngle(9,(360 -  (MinuteIncrement * time("min"))))
EGPClock:egpAngle(11,(360 - (HourIncrement   * (time("hour") + CFG_HourOffset))))
SecondIncrement = (360 / 60)
MinuteIncrement = (360 / 60)
HourIncrement   = (360 / 12)

